{"version":3,"file":"181.bundle.e24dc78addbb89a2c647.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/ViewportImageScrollbar.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/utils.ts","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/CustomizableViewportOverlay.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/ViewportOrientationMarkers.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/ViewportImageSliceLoadingIndicator.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/CornerstoneOverlays.tsx","webpack:///../../../extensions/cornerstone/src/components/CinePlayer/CinePlayer.tsx","webpack:///../../../extensions/cornerstone/src/components/CinePlayer/index.ts","webpack:///../../../extensions/cornerstone/src/Viewport/OHIFCornerstoneViewport.tsx"],"sourcesContent":["import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Enums, Types, utilities } from '@cornerstonejs/core';\nimport { utilities as csToolsUtils } from '@cornerstonejs/tools';\nimport { ImageScrollbar } from '@ohif/ui';\nimport { ServicesManger } from '@ohif/core';\n\nfunction CornerstoneImageScrollbar({\n  viewportData,\n  viewportId,\n  element,\n  imageSliceData,\n  setImageSliceData,\n  scrollbarHeight,\n  servicesManager,\n}) {\n  const { cineService, cornerstoneViewportService } = (servicesManager as ServicesManger).services;\n\n  const onImageScrollbarChange = (imageIndex, viewportId) => {\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n    const { isCineEnabled } = cineService.getState();\n\n    if (isCineEnabled) {\n      // on image scrollbar change, stop the CINE if it is playing\n      cineService.stopClip(element);\n      cineService.setCine({ id: viewportId, isPlaying: false });\n    }\n\n    csToolsUtils.jumpToSlice(viewport.element, {\n      imageIndex,\n      debounceLoading: true,\n    });\n  };\n\n  useEffect(() => {\n    if (!viewportData) {\n      return;\n    }\n\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n    if (!viewport) {\n      return;\n    }\n\n    if (viewportData.viewportType === Enums.ViewportType.STACK) {\n      const imageIndex = viewport.getCurrentImageIdIndex();\n\n      setImageSliceData({\n        imageIndex: imageIndex,\n        numberOfSlices: viewportData.data.imageIds.length,\n      });\n\n      return;\n    }\n\n    if (viewportData.viewportType === Enums.ViewportType.ORTHOGRAPHIC) {\n      const sliceData = utilities.getImageSliceDataForVolumeViewport(\n        viewport as Types.IVolumeViewport\n      );\n\n      if (!sliceData) {\n        return;\n      }\n\n      const { imageIndex, numberOfSlices } = sliceData;\n      setImageSliceData({ imageIndex, numberOfSlices });\n    }\n  }, [viewportId, viewportData]);\n\n  useEffect(() => {\n    if (viewportData?.viewportType !== Enums.ViewportType.STACK) {\n      return;\n    }\n\n    const updateStackIndex = event => {\n      const { newImageIdIndex } = event.detail;\n      // find the index of imageId in the imageIds\n      setImageSliceData({\n        imageIndex: newImageIdIndex,\n        numberOfSlices: viewportData.data.imageIds.length,\n      });\n    };\n\n    element.addEventListener(Enums.Events.STACK_VIEWPORT_SCROLL, updateStackIndex);\n\n    return () => {\n      element.removeEventListener(Enums.Events.STACK_VIEWPORT_SCROLL, updateStackIndex);\n    };\n  }, [viewportData, element]);\n\n  useEffect(() => {\n    if (viewportData?.viewportType !== Enums.ViewportType.ORTHOGRAPHIC) {\n      return;\n    }\n\n    const updateVolumeIndex = event => {\n      const { imageIndex, numberOfSlices } = event.detail;\n      // find the index of imageId in the imageIds\n      setImageSliceData({ imageIndex, numberOfSlices });\n    };\n\n    element.addEventListener(Enums.Events.VOLUME_NEW_IMAGE, updateVolumeIndex);\n\n    return () => {\n      element.removeEventListener(Enums.Events.VOLUME_NEW_IMAGE, updateVolumeIndex);\n    };\n  }, [viewportData, element]);\n\n  return (\n    <ImageScrollbar\n      onChange={evt => onImageScrollbarChange(evt, viewportId)}\n      max={imageSliceData.numberOfSlices ? imageSliceData.numberOfSlices - 1 : 0}\n      height={scrollbarHeight}\n      value={imageSliceData.imageIndex}\n    />\n  );\n}\n\nCornerstoneImageScrollbar.propTypes = {\n  viewportData: PropTypes.object,\n  viewportId: PropTypes.string.isRequired,\n  element: PropTypes.instanceOf(Element),\n  scrollbarHeight: PropTypes.string,\n  imageSliceData: PropTypes.object.isRequired,\n  setImageSliceData: PropTypes.func.isRequired,\n  servicesManager: PropTypes.object.isRequired,\n};\n\nexport default CornerstoneImageScrollbar;\n","import moment from 'moment';\nimport { metaData } from '@cornerstonejs/core';\n\n/**\n * Checks if value is valid.\n *\n * @param {number} value\n * @returns {boolean} is valid.\n */\nexport function isValidNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Formats number precision.\n *\n * @param {number} number\n * @param {number} precision\n * @returns {number} formatted number.\n */\nexport function formatNumberPrecision(number, precision = 0) {\n  if (number !== null) {\n    return parseFloat(number).toFixed(precision);\n  }\n}\n\n/**\n * Formats DICOM date.\n *\n * @param {string} date\n * @param {string} strFormat\n * @returns {string} formatted date.\n */\nexport function formatDICOMDate(date, strFormat = 'MMM D, YYYY') {\n  return moment(date, 'YYYYMMDD').format(strFormat);\n}\n\n/**\n *    DICOM Time is stored as HHmmss.SSS, where:\n *      HH 24 hour time:\n *        m mm        0..59   Minutes\n *        s ss        0..59   Seconds\n *        S SS SSS    0..999  Fractional seconds\n *\n *        Goal: '24:12:12'\n *\n * @param {*} time\n * @param {string} strFormat\n * @returns {string} formatted name.\n */\nexport function formatDICOMTime(time, strFormat = 'HH:mm:ss') {\n  return moment(time, 'HH:mm:ss').format(strFormat);\n}\n\n/**\n * Formats a patient name for display purposes\n *\n * @param {string} name\n * @returns {string} formatted name.\n */\nexport function formatPN(name) {\n  if (!name) {\n    return '';\n  }\n\n  const cleaned = name\n    .split('^')\n    .filter(s => !!s)\n    .join(', ')\n    .trim();\n  return cleaned === ',' || cleaned === '' ? '' : cleaned;\n}\n\n/**\n * Gets compression type\n *\n * @param {number} imageId\n * @returns {string} compression type.\n */\nexport function getCompression(imageId) {\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\n  const { lossyImageCompression, lossyImageCompressionRatio, lossyImageCompressionMethod } =\n    generalImageModule;\n\n  if (lossyImageCompression === '01' && lossyImageCompressionRatio !== '') {\n    const compressionMethod = lossyImageCompressionMethod || 'Lossy: ';\n    const compressionRatio = formatNumberPrecision(lossyImageCompressionRatio, 2);\n    return compressionMethod + compressionRatio + ' : 1';\n  }\n\n  return 'Lossless / Uncompressed';\n}\n","import React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport { vec3 } from 'gl-matrix';\nimport PropTypes from 'prop-types';\nimport { metaData, Enums, utilities } from '@cornerstonejs/core';\nimport { ViewportOverlay } from '@ohif/ui';\nimport { formatPN, formatDICOMDate, formatDICOMTime, formatNumberPrecision } from './utils';\nimport { InstanceMetadata } from 'platform/core/src/types';\nimport { ServicesManager } from '@ohif/core';\nimport { ImageSliceData } from '@cornerstonejs/core/dist/esm/types';\n\nimport './CustomizableViewportOverlay.css';\n\nconst EPSILON = 1e-4;\n\ninterface OverlayItemProps {\n  element: any;\n  viewportData: any;\n  imageSliceData: ImageSliceData;\n  servicesManager: ServicesManager;\n  instance: InstanceMetadata;\n  customization: any;\n  formatters: {\n    formatPN: (val) => string;\n    formatDate: (val) => string;\n    formatTime: (val) => string;\n    formatNumberPrecision: (val, number) => string;\n  };\n\n  // calculated values\n  voi: {\n    windowWidth: number;\n    windowCenter: number;\n  };\n  instanceNumber?: number;\n  scale?: number;\n}\n\n/**\n * Window Level / Center Overlay item\n */\nfunction VOIOverlayItem({ voi, customization }: OverlayItemProps) {\n  const { windowWidth, windowCenter } = voi;\n  if (typeof windowCenter !== 'number' || typeof windowWidth !== 'number') {\n    return null;\n  }\n\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: (customization && customization.color) || undefined }}\n    >\n      <span className=\"mr-1 shrink-0\">W:</span>\n      <span className=\"ml-1 mr-2 shrink-0 font-light\">{windowWidth.toFixed(0)}</span>\n      <span className=\"mr-1 shrink-0\">L:</span>\n      <span className=\"ml-1 shrink-0 font-light\">{windowCenter.toFixed(0)}</span>\n    </div>\n  );\n}\n\n/**\n * Zoom Level Overlay item\n */\nfunction ZoomOverlayItem({ scale, customization }: OverlayItemProps) {\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: (customization && customization.color) || undefined }}\n    >\n      <span className=\"mr-1 shrink-0\">Zoom:</span>\n      <span className=\"font-light\">{scale.toFixed(2)}x</span>\n    </div>\n  );\n}\n\n/**\n * Instance Number Overlay Item\n */\nfunction InstanceNumberOverlayItem({\n  instanceNumber,\n  imageSliceData,\n  customization,\n}: OverlayItemProps) {\n  const { imageIndex, numberOfSlices } = imageSliceData;\n\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: (customization && customization.color) || undefined }}\n    >\n      <span className=\"mr-1 shrink-0\">I:</span>\n      <span className=\"font-light\">\n        {instanceNumber !== undefined && instanceNumber !== null\n          ? `${instanceNumber} (${imageIndex + 1}/${numberOfSlices})`\n          : `${imageIndex + 1}/${numberOfSlices}`}\n      </span>\n    </div>\n  );\n}\n\n/**\n * Customizable Viewport Overlay\n */\nfunction CustomizableViewportOverlay({\n  element,\n  viewportData,\n  imageSliceData,\n  viewportId,\n  servicesManager,\n}) {\n  const { toolbarService, cornerstoneViewportService, customizationService } =\n    servicesManager.services;\n  const [voi, setVOI] = useState({ windowCenter: null, windowWidth: null });\n  const [scale, setScale] = useState(1);\n  const [activeTools, setActiveTools] = useState([]);\n  const { imageIndex } = imageSliceData;\n\n  const topLeftCustomization = customizationService.getModeCustomization(\n    'cornerstoneOverlayTopLeft'\n  );\n  const topRightCustomization = customizationService.getModeCustomization(\n    'cornerstoneOverlayTopRight'\n  );\n  const bottomLeftCustomization = customizationService.getModeCustomization(\n    'cornerstoneOverlayBottomLeft'\n  );\n  const bottomRightCustomization = customizationService.getModeCustomization(\n    'cornerstoneOverlayBottomRight'\n  );\n\n  const instance = useMemo(() => {\n    if (viewportData != null) {\n      return _getViewportInstance(viewportData, imageIndex);\n    } else {\n      return null;\n    }\n  }, [viewportData, imageIndex]);\n\n  const instanceNumber = useMemo(() => {\n    if (viewportData != null) {\n      return _getInstanceNumber(viewportData, viewportId, imageIndex, cornerstoneViewportService);\n    }\n    return null;\n  }, [viewportData, viewportId, imageIndex, cornerstoneViewportService]);\n\n  /**\n   * Initial toolbar state\n   */\n  useEffect(() => {\n    setActiveTools(toolbarService.getActiveTools());\n  }, []);\n\n  /**\n   * Updating the VOI when the viewport changes its voi\n   */\n  useEffect(() => {\n    const updateVOI = eventDetail => {\n      const { range } = eventDetail.detail;\n\n      if (!range) {\n        return;\n      }\n\n      const { lower, upper } = range;\n      const { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n\n      setVOI({ windowCenter, windowWidth });\n    };\n\n    element.addEventListener(Enums.Events.VOI_MODIFIED, updateVOI);\n\n    return () => {\n      element.removeEventListener(Enums.Events.VOI_MODIFIED, updateVOI);\n    };\n  }, [viewportId, viewportData, voi, element]);\n\n  /**\n   * Updating the scale when the viewport changes its zoom\n   */\n  useEffect(() => {\n    const updateScale = eventDetail => {\n      const { previousCamera, camera } = eventDetail.detail;\n\n      if (\n        previousCamera.parallelScale !== camera.parallelScale ||\n        previousCamera.scale !== camera.scale\n      ) {\n        const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n        if (!viewport) {\n          return;\n        }\n\n        const imageData = viewport.getImageData();\n\n        if (!imageData) {\n          return;\n        }\n\n        if (camera.scale) {\n          setScale(camera.scale);\n          return;\n        }\n\n        const { spacing } = imageData;\n        // convert parallel scale to scale\n        const scale = (element.clientHeight * spacing[0] * 0.5) / camera.parallelScale;\n        setScale(scale);\n      }\n    };\n\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, updateScale);\n\n    return () => {\n      element.removeEventListener(Enums.Events.CAMERA_MODIFIED, updateScale);\n    };\n  }, [viewportId, viewportData, cornerstoneViewportService, element]);\n\n  /**\n   * Updating the active tools when the toolbar changes\n   */\n  // Todo: this should act on the toolGroups instead of the toolbar state\n  useEffect(() => {\n    const { unsubscribe } = toolbarService.subscribe(\n      toolbarService.EVENTS.TOOL_BAR_STATE_MODIFIED,\n      () => {\n        setActiveTools(toolbarService.getActiveTools());\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [toolbarService]);\n\n  const _renderOverlayItem = useCallback(\n    item => {\n      const overlayItemProps: OverlayItemProps = {\n        element,\n        viewportData,\n        imageSliceData,\n        viewportId,\n        servicesManager,\n        customization: item,\n        formatters: {\n          formatPN: formatPN,\n          formatDate: formatDICOMDate,\n          formatTime: formatDICOMTime,\n          formatNumberPrecision: formatNumberPrecision,\n        },\n        instance,\n        // calculated\n        voi,\n        scale,\n        instanceNumber,\n      };\n\n      if (item.customizationType === 'ohif.overlayItem.windowLevel') {\n        return <VOIOverlayItem {...overlayItemProps} />;\n      } else if (item.customizationType === 'ohif.overlayItem.zoomLevel') {\n        return <ZoomOverlayItem {...overlayItemProps} />;\n      } else if (item.customizationType === 'ohif.overlayItem.instanceNumber') {\n        return <InstanceNumberOverlayItem {...overlayItemProps} />;\n      } else {\n        const renderItem = customizationService.transform(item);\n\n        if (typeof renderItem.content === 'function') {\n          return renderItem.content(overlayItemProps);\n        }\n      }\n    },\n    [\n      element,\n      viewportData,\n      imageSliceData,\n      viewportId,\n      servicesManager,\n      customizationService,\n      instance,\n      voi,\n      scale,\n      instanceNumber,\n    ]\n  );\n\n  const getTopLeftContent = useCallback(() => {\n    const items = topLeftCustomization?.items || [\n      {\n        id: 'WindowLevel',\n        customizationType: 'ohif.overlayItem.windowLevel',\n      },\n    ];\n    return (\n      <>\n        {items.map((item, i) => (\n          <div key={`topLeftOverlayItem_${i}`}>{_renderOverlayItem(item)}</div>\n        ))}\n      </>\n    );\n  }, [topLeftCustomization, _renderOverlayItem]);\n\n  const getTopRightContent = useCallback(() => {\n    const items = topRightCustomization?.items || [\n      {\n        id: 'InstanceNmber',\n        customizationType: 'ohif.overlayItem.instanceNumber',\n      },\n    ];\n    return (\n      <>\n        {items.map((item, i) => (\n          <div key={`topRightOverlayItem_${i}`}>{_renderOverlayItem(item)}</div>\n        ))}\n      </>\n    );\n  }, [topRightCustomization, _renderOverlayItem]);\n\n  const getBottomLeftContent = useCallback(() => {\n    const items = bottomLeftCustomization?.items || [];\n    return (\n      <>\n        {items.map((item, i) => (\n          <div key={`bottomLeftOverlayItem_${i}`}>{_renderOverlayItem(item)}</div>\n        ))}\n      </>\n    );\n  }, [bottomLeftCustomization, _renderOverlayItem]);\n\n  const getBottomRightContent = useCallback(() => {\n    const items = bottomRightCustomization?.items || [];\n    return (\n      <>\n        {items.map((item, i) => (\n          <div key={`bottomRightOverlayItem_${i}`}>{_renderOverlayItem(item)}</div>\n        ))}\n      </>\n    );\n  }, [bottomRightCustomization, _renderOverlayItem]);\n\n  return (\n    <ViewportOverlay\n      topLeft={getTopLeftContent()}\n      topRight={getTopRightContent()}\n      bottomLeft={getBottomLeftContent()}\n      bottomRight={getBottomRightContent()}\n    />\n  );\n}\n\nfunction _getViewportInstance(viewportData, imageIndex) {\n  let imageId = null;\n  if (viewportData.viewportType === Enums.ViewportType.STACK) {\n    imageId = viewportData.data.imageIds[imageIndex];\n  } else if (viewportData.viewportType === Enums.ViewportType.ORTHOGRAPHIC) {\n    const volumes = viewportData.data;\n    if (volumes && volumes.length == 1) {\n      const volume = volumes[0];\n      imageId = volume.imageIds[imageIndex];\n    }\n  }\n  return imageId ? metaData.get('instance', imageId) || {} : {};\n}\n\nfunction _getInstanceNumber(viewportData, viewportId, imageIndex, cornerstoneViewportService) {\n  let instanceNumber;\n\n  if (viewportData.viewportType === Enums.ViewportType.STACK) {\n    instanceNumber = _getInstanceNumberFromStack(viewportData, imageIndex);\n\n    if (!instanceNumber && instanceNumber !== 0) {\n      return null;\n    }\n  } else if (viewportData.viewportType === Enums.ViewportType.ORTHOGRAPHIC) {\n    instanceNumber = _getInstanceNumberFromVolume(\n      viewportData,\n      imageIndex,\n      viewportId,\n      cornerstoneViewportService\n    );\n  }\n  return instanceNumber;\n}\n\nfunction _getInstanceNumberFromStack(viewportData, imageIndex) {\n  const imageIds = viewportData.data.imageIds;\n  const imageId = imageIds[imageIndex];\n\n  if (!imageId) {\n    return;\n  }\n\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\n  const { instanceNumber } = generalImageModule;\n\n  const stackSize = imageIds.length;\n\n  if (stackSize <= 1) {\n    return;\n  }\n\n  return parseInt(instanceNumber);\n}\n\n// Since volume viewports can be in any view direction, they can render\n// a reconstructed image which don't have imageIds; therefore, no instance and instanceNumber\n// Here we check if viewport is in the acquisition direction and if so, we get the instanceNumber\nfunction _getInstanceNumberFromVolume(viewportData, viewportId, cornerstoneViewportService) {\n  const volumes = viewportData.volumes;\n\n  // Todo: support fusion of acquisition plane which has instanceNumber\n  if (!volumes || volumes.length > 1) {\n    return;\n  }\n\n  const volume = volumes[0];\n  const { direction, imageIds } = volume;\n\n  const cornerstoneViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n  if (!cornerstoneViewport) {\n    return;\n  }\n\n  const camera = cornerstoneViewport.getCamera();\n  const { viewPlaneNormal } = camera;\n  // checking if camera is looking at the acquisition plane (defined by the direction on the volume)\n\n  const scanAxisNormal = direction.slice(6, 9);\n\n  // check if viewPlaneNormal is parallel to scanAxisNormal\n  const cross = vec3.cross(vec3.create(), viewPlaneNormal, scanAxisNormal);\n  const isAcquisitionPlane = vec3.length(cross) < EPSILON;\n\n  if (isAcquisitionPlane) {\n    const imageId = imageIds[imageIndex];\n\n    if (!imageId) {\n      return {};\n    }\n\n    const { instanceNumber } = metaData.get('generalImageModule', imageId) || {};\n    return parseInt(instanceNumber);\n  }\n}\n\nCustomizableViewportOverlay.propTypes = {\n  viewportData: PropTypes.object,\n  imageIndex: PropTypes.number,\n  viewportId: PropTypes.string,\n};\n\nexport default CustomizableViewportOverlay;\n","import React, { useEffect, useState, useMemo } from 'react';\nimport classNames from 'classnames';\nimport {\n  metaData,\n  Enums,\n  Types,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/tools';\nimport PropTypes from 'prop-types';\nimport { vec3 } from 'gl-matrix';\n\nimport './ViewportOrientationMarkers.css';\n\nconst { getOrientationStringLPS, invertOrientationStringLPS } = utilities.orientation;\n\nfunction ViewportOrientationMarkers({\n  element,\n  viewportData,\n  imageSliceData,\n  viewportId,\n  servicesManager,\n  orientationMarkers = ['top', 'left'],\n}) {\n  // Rotation is in degrees\n  const [rotation, setRotation] = useState(0);\n  const [flipHorizontal, setFlipHorizontal] = useState(false);\n  const [flipVertical, setFlipVertical] = useState(false);\n  const { cornerstoneViewportService } = servicesManager.services;\n\n  useEffect(() => {\n    const cameraModifiedListener = (evt: Types.EventTypes.CameraModifiedEvent) => {\n      const { rotation, previousCamera, camera } = evt.detail;\n\n      if (rotation !== undefined) {\n        setRotation(rotation);\n      }\n\n      if (\n        camera.flipHorizontal !== undefined &&\n        previousCamera.flipHorizontal !== camera.flipHorizontal\n      ) {\n        setFlipHorizontal(camera.flipHorizontal);\n      }\n\n      if (\n        camera.flipVertical !== undefined &&\n        previousCamera.flipVertical !== camera.flipVertical\n      ) {\n        setFlipVertical(camera.flipVertical);\n      }\n    };\n\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, cameraModifiedListener);\n\n    return () => {\n      element.removeEventListener(Enums.Events.CAMERA_MODIFIED, cameraModifiedListener);\n    };\n  }, []);\n\n  const markers = useMemo(() => {\n    if (!viewportData) {\n      return '';\n    }\n\n    let rowCosines, columnCosines;\n    if (viewportData.viewportType === 'stack') {\n      const imageIndex = imageSliceData.imageIndex;\n      const imageId = viewportData.data.imageIds?.[imageIndex];\n\n      // Workaround for below TODO stub\n      if (!imageId) {\n        return false;\n      }\n\n      ({ rowCosines, columnCosines } = metaData.get('imagePlaneModule', imageId) || {});\n    } else {\n      if (!element || !getEnabledElement(element)) {\n        return '';\n      }\n\n      const { viewport } = getEnabledElement(element);\n      const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n      const viewRight = vec3.create();\n      vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n      columnCosines = [-viewUp[0], -viewUp[1], -viewUp[2]];\n      rowCosines = viewRight;\n    }\n\n    if (!rowCosines || !columnCosines || rotation === undefined) {\n      return '';\n    }\n\n    const markers = _getOrientationMarkers(\n      rowCosines,\n      columnCosines,\n      rotation,\n      flipVertical,\n      flipHorizontal\n    );\n\n    const ohifViewport = cornerstoneViewportService.getViewportInfo(viewportId);\n\n    if (!ohifViewport) {\n      console.log('ViewportOrientationMarkers::No viewport');\n      return null;\n    }\n    const backgroundColor = ohifViewport.getViewportOptions().background;\n\n    // Todo: probably this can be done in a better way in which we identify bright\n    // background\n    const isLight = backgroundColor ? csUtils.isEqual(backgroundColor, [1, 1, 1]) : false;\n\n    return orientationMarkers.map((m, index) => (\n      <div\n        className={classNames(\n          `${m}-mid orientation-marker`,\n          isLight ? 'text-[#726F7E]' : 'text-[#ccc]'\n        )}\n        key={`${m}-mid orientation-marker`}\n      >\n        <div className=\"orientation-marker-value\">{markers[m]}</div>\n      </div>\n    ));\n  }, [\n    viewportData,\n    imageSliceData,\n    rotation,\n    flipVertical,\n    flipHorizontal,\n    orientationMarkers,\n    element,\n  ]);\n\n  return <div className=\"ViewportOrientationMarkers noselect\">{markers}</div>;\n}\n\nViewportOrientationMarkers.propTypes = {\n  percentComplete: PropTypes.number,\n  error: PropTypes.object,\n};\n\nViewportOrientationMarkers.defaultProps = {\n  percentComplete: 0,\n  error: null,\n};\n\n/**\n *\n * Computes the orientation labels on a Cornerstone-enabled Viewport element\n * when the viewport settings change (e.g. when a horizontal flip or a rotation occurs)\n *\n * @param {*} rowCosines\n * @param {*} columnCosines\n * @param {*} rotation in degrees\n * @returns\n */\nfunction _getOrientationMarkers(rowCosines, columnCosines, rotation, flipVertical, flipHorizontal) {\n  const rowString = getOrientationStringLPS(rowCosines);\n  const columnString = getOrientationStringLPS(columnCosines);\n  const oppositeRowString = invertOrientationStringLPS(rowString);\n  const oppositeColumnString = invertOrientationStringLPS(columnString);\n\n  const markers = {\n    top: oppositeColumnString,\n    left: oppositeRowString,\n    right: rowString,\n    bottom: columnString,\n  };\n\n  // If any vertical or horizontal flips are applied, change the orientation strings ahead of\n  // the rotation applications\n  if (flipVertical) {\n    markers.top = invertOrientationStringLPS(markers.top);\n    markers.bottom = invertOrientationStringLPS(markers.bottom);\n  }\n\n  if (flipHorizontal) {\n    markers.left = invertOrientationStringLPS(markers.left);\n    markers.right = invertOrientationStringLPS(markers.right);\n  }\n\n  // Swap the labels accordingly if the viewport has been rotated\n  // This could be done in a more complex way for intermediate rotation values (e.g. 45 degrees)\n  if (rotation === 90 || rotation === -270) {\n    return {\n      top: markers.left,\n      left: invertOrientationStringLPS(markers.top),\n      right: invertOrientationStringLPS(markers.bottom),\n      bottom: markers.right, // left\n    };\n  } else if (rotation === -90 || rotation === 270) {\n    return {\n      top: invertOrientationStringLPS(markers.left),\n      left: markers.top,\n      bottom: markers.left,\n      right: markers.bottom,\n    };\n  } else if (rotation === 180 || rotation === -180) {\n    return {\n      top: invertOrientationStringLPS(markers.top),\n      left: invertOrientationStringLPS(markers.left),\n      bottom: invertOrientationStringLPS(markers.bottom),\n      right: invertOrientationStringLPS(markers.right),\n    };\n  }\n\n  return markers;\n}\n\nexport default ViewportOrientationMarkers;\n","import React, { useEffect, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Enums } from '@cornerstonejs/core';\n\nfunction ViewportImageSliceLoadingIndicator({ viewportData, element }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(false);\n\n  const loadIndicatorRef = useRef(null);\n  const imageIdToBeLoaded = useRef(null);\n\n  const setLoadingState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    loadIndicatorRef.current = setTimeout(() => {\n      setLoading(true);\n    }, 50);\n  };\n\n  const setFinishLoadingState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    setLoading(false);\n  };\n\n  const setErrorState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    if (imageIdToBeLoaded.current === evt.detail.imageId) {\n      setError(evt.detail.error);\n      imageIdToBeLoaded.current = null;\n    }\n  };\n\n  useEffect(() => {\n    element.addEventListener(Enums.Events.STACK_VIEWPORT_SCROLL, setLoadingState);\n    element.addEventListener(Enums.Events.IMAGE_LOAD_ERROR, setErrorState);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, setFinishLoadingState);\n\n    return () => {\n      element.removeEventListener(Enums.Events.STACK_VIEWPORT_SCROLL, setLoadingState);\n\n      element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, setFinishLoadingState);\n\n      element.removeEventListener(Enums.Events.IMAGE_LOAD_ERROR, setErrorState);\n    };\n  }, [element, viewportData]);\n\n  if (error) {\n    return (\n      <>\n        <div className=\"absolute top-0 left-0 h-full w-full bg-black opacity-50\">\n          <div className=\"transparent flex h-full w-full items-center justify-center\">\n            <p className=\"text-primary-light text-xl font-light\">\n              <h4>Error Loading Image</h4>\n              <p>An error has occurred.</p>\n              <p>{error}</p>\n            </p>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  if (loading) {\n    return (\n      // IMPORTANT: we need to use the pointer-events-none class to prevent the loading indicator from\n      // interacting with the mouse, since scrolling should propagate to the viewport underneath\n      <div className=\"pointer-events-none absolute top-0 left-0 h-full w-full bg-black opacity-50\">\n        <div className=\"transparent flex h-full w-full items-center justify-center\">\n          <p className=\"text-primary-light text-xl font-light\">Loading...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return null;\n}\n\nViewportImageSliceLoadingIndicator.propTypes = {\n  percentComplete: PropTypes.number,\n  error: PropTypes.object,\n  element: PropTypes.object,\n};\n\nViewportImageSliceLoadingIndicator.defaultProps = {\n  percentComplete: 0,\n  error: null,\n};\n\nexport default ViewportImageSliceLoadingIndicator;\n","import React, { useEffect, useState } from 'react';\n\nimport ViewportImageScrollbar from './ViewportImageScrollbar';\nimport CustomizableViewportOverlay from './CustomizableViewportOverlay';\nimport ViewportOrientationMarkers from './ViewportOrientationMarkers';\nimport ViewportImageSliceLoadingIndicator from './ViewportImageSliceLoadingIndicator';\n\nfunction CornerstoneOverlays(props) {\n  const { viewportId, element, scrollbarHeight, servicesManager } = props;\n  const { cornerstoneViewportService } = servicesManager.services;\n  const [imageSliceData, setImageSliceData] = useState({\n    imageIndex: 0,\n    numberOfSlices: 0,\n  });\n  const [viewportData, setViewportData] = useState(null);\n\n  useEffect(() => {\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\n      props => {\n        if (props.viewportId !== viewportId) {\n          return;\n        }\n\n        setViewportData(props.viewportData);\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [viewportId]);\n\n  if (!element) {\n    return null;\n  }\n\n  if (viewportData) {\n    const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n\n    if (viewportInfo?.viewportOptions?.customViewportProps?.hideOverlays) {\n      return null;\n    }\n  }\n\n  return (\n    <div className=\"noselect\">\n      <ViewportImageScrollbar\n        viewportId={viewportId}\n        viewportData={viewportData}\n        element={element}\n        imageSliceData={imageSliceData}\n        setImageSliceData={setImageSliceData}\n        scrollbarHeight={scrollbarHeight}\n        servicesManager={servicesManager}\n      />\n\n      <CustomizableViewportOverlay\n        imageSliceData={imageSliceData}\n        viewportData={viewportData}\n        viewportId={viewportId}\n        servicesManager={servicesManager}\n        element={element}\n      />\n\n      <ViewportImageSliceLoadingIndicator\n        viewportData={viewportData}\n        element={element}\n      />\n\n      <ViewportOrientationMarkers\n        imageSliceData={imageSliceData}\n        element={element}\n        viewportData={viewportData}\n        servicesManager={servicesManager}\n        viewportId={viewportId}\n      />\n    </div>\n  );\n}\n\nexport default CornerstoneOverlays;\n","import React, { useCallback, useEffect, useState } from 'react';\nimport { CinePlayer, useCine, useViewportGrid } from '@ohif/ui';\nimport { Enums, eventTarget } from '@cornerstonejs/core';\nimport { useAppConfig } from '@state';\n\nfunction WrappedCinePlayer({ enabledVPElement, viewportId, servicesManager }) {\n  const {\n    toolbarService,\n    customizationService,\n    displaySetService,\n    viewportGridService,\n    cineService,\n  } = servicesManager.services;\n  const [{ isCineEnabled, cines }] = useCine();\n  const [newStackFrameRate, setNewStackFrameRate] = useState(24);\n  const [appConfig] = useAppConfig();\n\n  const { component: CinePlayerComponent = CinePlayer } =\n    customizationService.get('cinePlayer') ?? {};\n\n  const handleCineClose = () => {\n    toolbarService.recordInteraction({\n      groupId: 'MoreTools',\n      interactionType: 'toggle',\n      commands: [\n        {\n          commandName: 'toggleCine',\n          commandOptions: {},\n          toolName: 'cine',\n          context: 'CORNERSTONE',\n        },\n      ],\n    });\n  };\n\n  const cineHandler = () => {\n    if (!cines || !cines[viewportId] || !enabledVPElement) {\n      return;\n    }\n\n    const cine = cines[viewportId];\n    const isPlaying = cine.isPlaying || false;\n    const frameRate = cine.frameRate || 24;\n\n    const validFrameRate = Math.max(frameRate, 1);\n\n    if (isPlaying) {\n      cineService.playClip(enabledVPElement, {\n        framesPerSecond: validFrameRate,\n      });\n    } else {\n      cineService.stopClip(enabledVPElement);\n    }\n  };\n\n  const newStackCineHandler = useCallback(() => {\n    const { viewports } = viewportGridService.getState();\n    const { displaySetInstanceUIDs } = viewports.get(viewportId);\n\n    let frameRate = 24;\n    let isPlaying = cines[viewportId].isPlaying;\n    displaySetInstanceUIDs.forEach(displaySetInstanceUID => {\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n      if (displaySet.FrameRate) {\n        // displaySet.FrameRate corresponds to DICOM tag (0018,1063) which is defined as the the frame time in milliseconds\n        // So a bit of math to get the actual frame rate.\n        frameRate = Math.round(1000 / displaySet.FrameRate);\n        isPlaying ||= !!appConfig.autoPlayCine;\n      }\n    });\n\n    if (isPlaying) {\n      cineService.setIsCineEnabled(isPlaying);\n    }\n    cineService.setCine({ id: viewportId, isPlaying, frameRate });\n    setNewStackFrameRate(frameRate);\n  }, [cineService, displaySetService, viewportId, viewportGridService, cines]);\n\n  useEffect(() => {\n    eventTarget.addEventListener(Enums.Events.STACK_VIEWPORT_NEW_STACK, newStackCineHandler);\n\n    return () => {\n      cineService.setCine({ id: viewportId, isPlaying: false });\n      eventTarget.removeEventListener(Enums.Events.STACK_VIEWPORT_NEW_STACK, newStackCineHandler);\n    };\n  }, [enabledVPElement, newStackCineHandler]);\n\n  useEffect(() => {\n    if (!cines || !cines[viewportId] || !enabledVPElement) {\n      return;\n    }\n\n    cineHandler();\n\n    return () => {\n      if (enabledVPElement && cines?.[viewportId]?.isPlaying) {\n        cineService.stopClip(enabledVPElement);\n      }\n    };\n  }, [cines, viewportId, cineService, enabledVPElement, cineHandler]);\n\n  const cine = cines[viewportId];\n  const isPlaying = (cine && cine.isPlaying) || false;\n\n  return (\n    isCineEnabled && (\n      <CinePlayerComponent\n        className=\"absolute left-1/2 bottom-3 -translate-x-1/2\"\n        frameRate={newStackFrameRate}\n        isPlaying={isPlaying}\n        onClose={handleCineClose}\n        onPlayPauseChange={isPlaying =>\n          cineService.setCine({\n            id: viewportId,\n            isPlaying,\n          })\n        }\n        onFrameRateChange={frameRate =>\n          cineService.setCine({\n            id: viewportId,\n            frameRate,\n          })\n        }\n      />\n    )\n  );\n}\n\nexport default WrappedCinePlayer;\n","import CinePlayer from './CinePlayer';\n\nexport default CinePlayer;\n","import React, { useEffect, useRef, useCallback, useState } from 'react';\nimport ReactResizeDetector from 'react-resize-detector';\nimport PropTypes from 'prop-types';\nimport * as cs3DTools from '@cornerstonejs/tools';\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { MeasurementService } from '@ohif/core';\nimport { Notification, useViewportDialog } from '@ohif/ui';\nimport { IStackViewport, IVolumeViewport } from '@cornerstonejs/core/dist/esm/types';\n\nimport { setEnabledElement } from '../state';\n\nimport './OHIFCornerstoneViewport.css';\nimport CornerstoneOverlays from './Overlays/CornerstoneOverlays';\nimport getSOPInstanceAttributes from '../utils/measurementServiceMappings/utils/getSOPInstanceAttributes';\nimport CornerstoneServices from '../types/CornerstoneServices';\nimport CinePlayer from '../components/CinePlayer';\nimport { Types } from '@ohif/core';\n\nconst STACK = 'stack';\n\n/**\n * Caches the jump to measurement operation, so that if display set is shown,\n * it can jump to the measurement.\n */\nlet cacheJumpToMeasurementEvent;\n\nfunction areEqual(prevProps, nextProps) {\n  if (nextProps.needsRerendering) {\n    return false;\n  }\n\n  if (prevProps.displaySets.length !== nextProps.displaySets.length) {\n    return false;\n  }\n\n  if (prevProps.viewportOptions.orientation !== nextProps.viewportOptions.orientation) {\n    return false;\n  }\n\n  if (prevProps.viewportOptions.toolGroupId !== nextProps.viewportOptions.toolGroupId) {\n    return false;\n  }\n\n  if (prevProps.viewportOptions.viewportType !== nextProps.viewportOptions.viewportType) {\n    return false;\n  }\n\n  if (nextProps.viewportOptions.needsRerendering) {\n    return false;\n  }\n\n  const prevDisplaySets = prevProps.displaySets;\n  const nextDisplaySets = nextProps.displaySets;\n\n  if (prevDisplaySets.length !== nextDisplaySets.length) {\n    return false;\n  }\n\n  for (let i = 0; i < prevDisplaySets.length; i++) {\n    const prevDisplaySet = prevDisplaySets[i];\n\n    const foundDisplaySet = nextDisplaySets.find(\n      nextDisplaySet =>\n        nextDisplaySet.displaySetInstanceUID === prevDisplaySet.displaySetInstanceUID\n    );\n\n    if (!foundDisplaySet) {\n      return false;\n    }\n\n    // check they contain the same image\n    if (foundDisplaySet.images?.length !== prevDisplaySet.images?.length) {\n      return false;\n    }\n\n    // check if their imageIds are the same\n    if (foundDisplaySet.images?.length) {\n      for (let j = 0; j < foundDisplaySet.images.length; j++) {\n        if (foundDisplaySet.images[j].imageId !== prevDisplaySet.images[j].imageId) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n// Todo: This should be done with expose of internal API similar to react-vtkjs-viewport\n// Then we don't need to worry about the re-renders if the props change.\nconst OHIFCornerstoneViewport = React.memo(props => {\n  const {\n    displaySets,\n    dataSource,\n    viewportOptions,\n    displaySetOptions,\n    servicesManager,\n    commandsManager,\n    onElementEnabled,\n    onElementDisabled,\n    isJumpToMeasurementDisabled,\n    // Note: you SHOULD NOT use the initialImageIdOrIndex for manipulation\n    // of the imageData in the OHIFCornerstoneViewport. This prop is used\n    // to set the initial state of the viewport's first image to render\n    initialImageIndex,\n  } = props;\n\n  const viewportId = viewportOptions.viewportId;\n  const [scrollbarHeight, setScrollbarHeight] = useState('100px');\n  const [enabledVPElement, setEnabledVPElement] = useState(null);\n  const elementRef = useRef();\n\n  const {\n    measurementService,\n    displaySetService,\n    toolbarService,\n    toolGroupService,\n    syncGroupService,\n    cornerstoneViewportService,\n    cornerstoneCacheService,\n    viewportGridService,\n    stateSyncService,\n  } = servicesManager.services as CornerstoneServices;\n\n  const [viewportDialogState] = useViewportDialog();\n  // useCallback for scroll bar height calculation\n  const setImageScrollBarHeight = useCallback(() => {\n    const scrollbarHeight = `${elementRef.current.clientHeight - 20}px`;\n    setScrollbarHeight(scrollbarHeight);\n  }, [elementRef]);\n\n  // useCallback for onResize\n  const onResize = useCallback(() => {\n    if (elementRef.current) {\n      cornerstoneViewportService.resize();\n      setImageScrollBarHeight();\n    }\n  }, [elementRef]);\n\n  const cleanUpServices = useCallback(\n    viewportInfo => {\n      const renderingEngineId = viewportInfo.getRenderingEngineId();\n      const syncGroups = viewportInfo.getSyncGroups();\n\n      toolGroupService.removeViewportFromToolGroup(viewportId, renderingEngineId);\n\n      syncGroupService.removeViewportFromSyncGroup(viewportId, renderingEngineId, syncGroups);\n    },\n    [viewportId]\n  );\n\n  const elementEnabledHandler = useCallback(\n    evt => {\n      // check this is this element reference and return early if doesn't match\n      if (evt.detail.element !== elementRef.current) {\n        return;\n      }\n\n      const { viewportId, element } = evt.detail;\n      const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n      setEnabledElement(viewportId, element);\n      setEnabledVPElement(element);\n\n      const renderingEngineId = viewportInfo.getRenderingEngineId();\n      const toolGroupId = viewportInfo.getToolGroupId();\n      const syncGroups = viewportInfo.getSyncGroups();\n\n      toolGroupService.addViewportToToolGroup(viewportId, renderingEngineId, toolGroupId);\n\n      syncGroupService.addViewportToSyncGroup(viewportId, renderingEngineId, syncGroups);\n\n      const synchronizersStore = stateSyncService.getState().synchronizersStore;\n\n      if (synchronizersStore?.[viewportId]?.length) {\n        // If the viewport used to have a synchronizer, re apply it again\n        _rehydrateSynchronizers(synchronizersStore, viewportId, syncGroupService);\n      }\n\n      if (onElementEnabled) {\n        onElementEnabled(evt);\n      }\n    },\n    [viewportId, onElementEnabled, toolGroupService]\n  );\n\n  // disable the element upon unmounting\n  useEffect(() => {\n    cornerstoneViewportService.enableViewport(viewportId, elementRef.current);\n\n    eventTarget.addEventListener(Enums.Events.ELEMENT_ENABLED, elementEnabledHandler);\n\n    setImageScrollBarHeight();\n\n    return () => {\n      const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n\n      if (!viewportInfo) {\n        return;\n      }\n\n      cornerstoneViewportService.storePresentation({ viewportId });\n\n      // This should be done after the store presentation since synchronizers\n      // will get cleaned up and they need the viewportInfo to be present\n      cleanUpServices(viewportInfo);\n\n      if (onElementDisabled) {\n        onElementDisabled(viewportInfo);\n      }\n\n      cornerstoneViewportService.disableElement(viewportId);\n\n      eventTarget.removeEventListener(Enums.Events.ELEMENT_ENABLED, elementEnabledHandler);\n    };\n  }, []);\n\n  // subscribe to displaySet metadata invalidation (updates)\n  // Currently, if the metadata changes we need to re-render the display set\n  // for it to take effect in the viewport. As we deal with scaling in the loading,\n  // we need to remove the old volume from the cache, and let the\n  // viewport to re-add it which will use the new metadata. Otherwise, the\n  // viewport will use the cached volume and the new metadata will not be used.\n  // Note: this approach does not actually end of sending network requests\n  // and it uses the network cache\n  useEffect(() => {\n    const { unsubscribe } = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SET_SERIES_METADATA_INVALIDATED,\n      async ({\n        displaySetInstanceUID: invalidatedDisplaySetInstanceUID,\n        invalidateData,\n      }: Types.DisplaySetSeriesMetadataInvalidatedEvent) => {\n        if (!invalidateData) {\n          return;\n        }\n\n        const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n\n        if (viewportInfo.hasDisplaySet(invalidatedDisplaySetInstanceUID)) {\n          const viewportData = viewportInfo.getViewportData();\n          const newViewportData = await cornerstoneCacheService.invalidateViewportData(\n            viewportData,\n            invalidatedDisplaySetInstanceUID,\n            dataSource,\n            displaySetService\n          );\n\n          const keepCamera = true;\n          cornerstoneViewportService.updateViewport(viewportId, newViewportData, keepCamera);\n        }\n      }\n    );\n    return () => {\n      unsubscribe();\n    };\n  }, [viewportId]);\n\n  useEffect(() => {\n    // handle the default viewportType to be stack\n    if (!viewportOptions.viewportType) {\n      viewportOptions.viewportType = STACK;\n    }\n\n    const loadViewportData = async () => {\n      const viewportData = await cornerstoneCacheService.createViewportData(\n        displaySets,\n        viewportOptions,\n        dataSource,\n        initialImageIndex\n      );\n\n      // The presentation state will have been stored previously by closing\n      // a viewport.  Otherwise, this viewport will be unchanged and the\n      // presentation information will be directly carried over.\n      const { lutPresentationStore, positionPresentationStore } = stateSyncService.getState();\n      const { presentationIds } = viewportOptions;\n      const presentations = {\n        positionPresentation: positionPresentationStore[presentationIds?.positionPresentationId],\n        lutPresentation: lutPresentationStore[presentationIds?.lutPresentationId],\n      };\n      let measurement;\n      if (cacheJumpToMeasurementEvent?.viewportId === viewportId) {\n        measurement = cacheJumpToMeasurementEvent.measurement;\n        // Delete the position presentation so that viewport navigates direct\n        presentations.positionPresentation = null;\n        cacheJumpToMeasurementEvent = null;\n      }\n\n      // Note: This is a hack to get the grid to re-render the OHIFCornerstoneViewport component\n      // Used for segmentation hydration right now, since the logic to decide whether\n      // a viewport needs to render a segmentation lives inside the CornerstoneViewportService\n      // so we need to re-render (force update via change of the needsRerendering) so that React\n      // does the diffing and decides we should render this again (although the id and element has not changed)\n      // so that the CornerstoneViewportService can decide whether to render the segmentation or not. Not that we reached here we can turn it off.\n      if (viewportOptions.needsRerendering) {\n        viewportOptions.needsRerendering = false;\n      }\n\n      cornerstoneViewportService.setViewportData(\n        viewportId,\n        viewportData,\n        viewportOptions,\n        displaySetOptions,\n        presentations\n      );\n      if (measurement) {\n        cs3DTools.annotation.selection.setAnnotationSelected(measurement.uid);\n      }\n    };\n\n    loadViewportData();\n  }, [viewportOptions, displaySets, dataSource]);\n\n  /**\n   * There are two scenarios for jump to click\n   * 1. Current viewports contain the displaySet that the annotation was drawn on\n   * 2. Current viewports don't contain the displaySet that the annotation was drawn on\n   * and we need to change the viewports displaySet for jumping.\n   * Since measurement_jump happens via events and listeners, the former case is handled\n   * by the measurement_jump direct callback, but the latter case is handled first by\n   * the viewportGrid to set the correct displaySet on the viewport, AND THEN we check\n   * the cache for jumping to see if there is any jump queued, then we jump to the correct slice.\n   */\n  useEffect(() => {\n    if (isJumpToMeasurementDisabled) {\n      return;\n    }\n\n    const unsubscribeFromJumpToMeasurementEvents = _subscribeToJumpToMeasurementEvents(\n      measurementService,\n      displaySetService,\n      elementRef,\n      viewportId,\n      displaySets,\n      viewportGridService,\n      cornerstoneViewportService\n    );\n\n    _checkForCachedJumpToMeasurementEvents(\n      measurementService,\n      displaySetService,\n      elementRef,\n      viewportId,\n      displaySets,\n      viewportGridService,\n      cornerstoneViewportService\n    );\n\n    return () => {\n      unsubscribeFromJumpToMeasurementEvents();\n    };\n  }, [displaySets, elementRef, viewportId]);\n\n  return (\n    <React.Fragment>\n      <div className=\"viewport-wrapper\">\n        <ReactResizeDetector\n          refreshMode=\"debounce\"\n          refreshRate={50} // Wait 50 ms after last move to render\n          onResize={onResize}\n          targetRef={elementRef.current}\n        />\n        <div\n          className=\"cornerstone-viewport-element\"\n          style={{ height: '100%', width: '100%' }}\n          onContextMenu={e => e.preventDefault()}\n          onMouseDown={e => e.preventDefault()}\n          ref={elementRef}\n        ></div>\n        <CornerstoneOverlays\n          viewportId={viewportId}\n          toolBarService={toolbarService}\n          element={elementRef.current}\n          scrollbarHeight={scrollbarHeight}\n          servicesManager={servicesManager}\n        />\n        <CinePlayer\n          enabledVPElement={enabledVPElement}\n          viewportId={viewportId}\n          servicesManager={servicesManager}\n        />\n      </div>\n      <div className=\"absolute w-full\">\n        {viewportDialogState.viewportId === viewportId && (\n          <Notification\n            id=\"viewport-notification\"\n            message={viewportDialogState.message}\n            type={viewportDialogState.type}\n            actions={viewportDialogState.actions}\n            onSubmit={viewportDialogState.onSubmit}\n            onOutsideClick={viewportDialogState.onOutsideClick}\n          />\n        )}\n      </div>\n    </React.Fragment>\n  );\n}, areEqual);\n\nfunction _subscribeToJumpToMeasurementEvents(\n  measurementService,\n  displaySetService,\n  elementRef,\n  viewportId,\n  displaySets,\n  viewportGridService,\n  cornerstoneViewportService\n) {\n  const { unsubscribe } = measurementService.subscribe(\n    MeasurementService.EVENTS.JUMP_TO_MEASUREMENT_VIEWPORT,\n    props => {\n      cacheJumpToMeasurementEvent = props;\n      const { viewportId: jumpId, measurement, isConsumed } = props;\n      if (!measurement || isConsumed) {\n        return;\n      }\n      if (cacheJumpToMeasurementEvent.cornerstoneViewport === undefined) {\n        // Decide on which viewport should handle this\n        cacheJumpToMeasurementEvent.cornerstoneViewport =\n          cornerstoneViewportService.getViewportIdToJump(\n            jumpId,\n            measurement.displaySetInstanceUID,\n            { referencedImageId: measurement.referencedImageId }\n          );\n      }\n      if (cacheJumpToMeasurementEvent.cornerstoneViewport !== viewportId) {\n        return;\n      }\n      _jumpToMeasurement(\n        measurement,\n        elementRef,\n        viewportId,\n        measurementService,\n        displaySetService,\n        viewportGridService,\n        cornerstoneViewportService\n      );\n    }\n  );\n\n  return unsubscribe;\n}\n\n// Check if there is a queued jumpToMeasurement event\nfunction _checkForCachedJumpToMeasurementEvents(\n  measurementService,\n  displaySetService,\n  elementRef,\n  viewportId,\n  displaySets,\n  viewportGridService,\n  cornerstoneViewportService\n) {\n  if (!cacheJumpToMeasurementEvent) {\n    return;\n  }\n  if (cacheJumpToMeasurementEvent.isConsumed) {\n    cacheJumpToMeasurementEvent = null;\n    return;\n  }\n  const displaysUIDs = displaySets.map(displaySet => displaySet.displaySetInstanceUID);\n  if (!displaysUIDs?.length) {\n    return;\n  }\n\n  // Jump to measurement if the measurement exists\n  const { measurement } = cacheJumpToMeasurementEvent;\n  if (measurement && elementRef) {\n    if (displaysUIDs.includes(measurement?.displaySetInstanceUID)) {\n      _jumpToMeasurement(\n        measurement,\n        elementRef,\n        viewportId,\n        measurementService,\n        displaySetService,\n        viewportGridService,\n        cornerstoneViewportService\n      );\n    }\n  }\n}\n\nfunction _jumpToMeasurement(\n  measurement,\n  targetElementRef,\n  viewportId,\n  measurementService,\n  displaySetService,\n  viewportGridService,\n  cornerstoneViewportService\n) {\n  const targetElement = targetElementRef.current;\n  const { displaySetInstanceUID, SOPInstanceUID, frameNumber } = measurement;\n\n  if (!SOPInstanceUID) {\n    console.warn('cannot jump in a non-acquisition plane measurements yet');\n    return;\n  }\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  // Todo: setCornerstoneMeasurementActive should be handled by the toolGroupManager\n  //  to set it properly\n  // setCornerstoneMeasurementActive(measurement);\n\n  viewportGridService.setActiveViewportId(viewportId);\n\n  const enabledElement = getEnabledElement(targetElement);\n\n  if (enabledElement) {\n    // See how the jumpToSlice() of Cornerstone3D deals with imageIdx param.\n    const viewport = enabledElement.viewport as IStackViewport | IVolumeViewport;\n\n    let imageIdIndex = 0;\n    let viewportCameraDirectionMatch = true;\n\n    if (viewport instanceof StackViewport) {\n      const imageIds = viewport.getImageIds();\n      imageIdIndex = imageIds.findIndex(imageId => {\n        const { SOPInstanceUID: aSOPInstanceUID, frameNumber: aFrameNumber } =\n          getSOPInstanceAttributes(imageId);\n        return aSOPInstanceUID === SOPInstanceUID && (!frameNumber || frameNumber === aFrameNumber);\n      });\n    } else {\n      // for volume viewport we can't rely on the imageIdIndex since it can be\n      // a reconstructed view that doesn't match the original slice numbers etc.\n      const { viewPlaneNormal: measurementViewPlane } = measurement.metadata;\n      imageIdIndex = referencedDisplaySet.images.findIndex(\n        i => i.SOPInstanceUID === SOPInstanceUID\n      );\n\n      const { viewPlaneNormal: viewportViewPlane } = viewport.getCamera();\n\n      // should compare abs for both planes since the direction can be flipped\n      if (\n        measurementViewPlane &&\n        !csUtils.isEqual(measurementViewPlane.map(Math.abs), viewportViewPlane.map(Math.abs))\n      ) {\n        viewportCameraDirectionMatch = false;\n      }\n    }\n\n    if (!viewportCameraDirectionMatch || imageIdIndex === -1) {\n      return;\n    }\n\n    cs3DTools.utilities.jumpToSlice(targetElement, {\n      imageIndex: imageIdIndex,\n    });\n\n    cs3DTools.annotation.selection.setAnnotationSelected(measurement.uid);\n    // Jump to measurement consumed, remove.\n    cacheJumpToMeasurementEvent?.consume?.();\n    cacheJumpToMeasurementEvent = null;\n  }\n}\n\nfunction _rehydrateSynchronizers(\n  synchronizersStore: { [key: string]: unknown },\n  viewportId: string,\n  syncGroupService: any\n) {\n  synchronizersStore[viewportId].forEach(synchronizerObj => {\n    if (!synchronizerObj.id) {\n      return;\n    }\n\n    const { id, sourceViewports, targetViewports } = synchronizerObj;\n\n    const synchronizer = syncGroupService.getSynchronizer(id);\n\n    if (!synchronizer) {\n      return;\n    }\n\n    const sourceViewportInfo = sourceViewports.find(\n      sourceViewport => sourceViewport.viewportId === viewportId\n    );\n\n    const targetViewportInfo = targetViewports.find(\n      targetViewport => targetViewport.viewportId === viewportId\n    );\n\n    const isSourceViewportInSynchronizer = synchronizer\n      .getSourceViewports()\n      .find(sourceViewport => sourceViewport.viewportId === viewportId);\n\n    const isTargetViewportInSynchronizer = synchronizer\n      .getTargetViewports()\n      .find(targetViewport => targetViewport.viewportId === viewportId);\n\n    // if the viewport was previously a source viewport, add it again\n    if (sourceViewportInfo && !isSourceViewportInSynchronizer) {\n      synchronizer.addSource({\n        viewportId: sourceViewportInfo.viewportId,\n        renderingEngineId: sourceViewportInfo.renderingEngineId,\n      });\n    }\n\n    // if the viewport was previously a target viewport, add it again\n    if (targetViewportInfo && !isTargetViewportInSynchronizer) {\n      synchronizer.addTarget({\n        viewportId: targetViewportInfo.viewportId,\n        renderingEngineId: targetViewportInfo.renderingEngineId,\n      });\n    }\n  });\n}\n\n// Component displayName\nOHIFCornerstoneViewport.displayName = 'OHIFCornerstoneViewport';\n\nOHIFCornerstoneViewport.defaultProps = {\n  isJumpToMeasurementDisabled: false,\n};\n\nOHIFCornerstoneViewport.propTypes = {\n  displaySets: PropTypes.array.isRequired,\n  dataSource: PropTypes.object.isRequired,\n  viewportOptions: PropTypes.object,\n  displaySetOptions: PropTypes.arrayOf(PropTypes.any),\n  servicesManager: PropTypes.object.isRequired,\n  onElementEnabled: PropTypes.func,\n  isJumpToMeasurementDisabled: PropTypes.bool,\n  // Note: you SHOULD NOT use the initialImageIdOrIndex for manipulation\n  // of the imageData in the OHIFCornerstoneViewport. This prop is used\n  // to set the initial state of the viewport's first image to render\n  initialImageIdOrIndex: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n};\n\nexport default OHIFCornerstoneViewport;\n"],"names":["CornerstoneImageScrollbar","viewportData","viewportId","element","imageSliceData","setImageSliceData","scrollbarHeight","servicesManager","cineService","cornerstoneViewportService","services","useEffect","viewport","getCornerstoneViewport","viewportType","Enums","STACK","ORTHOGRAPHIC","sliceData","utilities","imageIndex","numberOfSlices","getCurrentImageIdIndex","data","imageIds","length","updateStackIndex","event","newImageIdIndex","detail","addEventListener","STACK_VIEWPORT_SCROLL","removeEventListener","updateVolumeIndex","VOLUME_NEW_IMAGE","React","ImageScrollbar","onChange","evt","onImageScrollbarChange","isCineEnabled","getState","stopClip","setCine","id","isPlaying","csToolsUtils","debounceLoading","max","height","value","propTypes","PropTypes","isRequired","Element","formatNumberPrecision","number","precision","parseFloat","toFixed","formatDICOMDate","date","strFormat","moment","format","formatDICOMTime","time","formatPN","name","cleaned","split","filter","s","join","trim","EPSILON","VOIOverlayItem","voi","customization","windowWidth","windowCenter","className","style","color","undefined","ZoomOverlayItem","scale","InstanceNumberOverlayItem","instanceNumber","CustomizableViewportOverlay","toolbarService","customizationService","setVOI","useState","setScale","activeTools","setActiveTools","topLeftCustomization","getModeCustomization","topRightCustomization","bottomLeftCustomization","bottomRightCustomization","instance","useMemo","imageId","volumes","metaData","_getViewportInstance","generalImageModule","parseInt","_getInstanceNumberFromStack","_getInstanceNumberFromVolume","_getInstanceNumber","getActiveTools","updateVOI","eventDetail","range","lower","upper","VOI_MODIFIED","updateScale","previousCamera","camera","parallelScale","imageData","getImageData","spacing","clientHeight","CAMERA_MODIFIED","unsubscribe","subscribe","EVENTS","TOOL_BAR_STATE_MODIFIED","_renderOverlayItem","useCallback","item","overlayItemProps","formatters","formatDate","formatTime","customizationType","renderItem","transform","content","getTopLeftContent","items","map","i","key","getTopRightContent","getBottomLeftContent","getBottomRightContent","ViewportOverlay","topLeft","topRight","bottomLeft","bottomRight","volume","direction","cornerstoneViewport","getCamera","viewPlaneNormal","scanAxisNormal","slice","cross","vec3","getOrientationStringLPS","invertOrientationStringLPS","ViewportOrientationMarkers","orientationMarkers","rotation","setRotation","flipHorizontal","setFlipHorizontal","flipVertical","setFlipVertical","cameraModifiedListener","markers","rowCosines","columnCosines","getEnabledElement","viewUp","viewRight","rowString","columnString","oppositeRowString","top","left","right","bottom","_getOrientationMarkers","ohifViewport","getViewportInfo","console","log","backgroundColor","getViewportOptions","background","isLight","csUtils","m","index","classNames","percentComplete","error","defaultProps","ViewportImageSliceLoadingIndicator","loading","setLoading","setError","loadIndicatorRef","useRef","imageIdToBeLoaded","setLoadingState","clearTimeout","current","setTimeout","setFinishLoadingState","setErrorState","IMAGE_LOAD_ERROR","STACK_NEW_IMAGE","props","setViewportData","VIEWPORT_DATA_CHANGED","viewportInfo","viewportOptions","customViewportProps","hideOverlays","ViewportImageScrollbar","enabledVPElement","displaySetService","viewportGridService","cines","useCine","newStackFrameRate","setNewStackFrameRate","appConfig","useAppConfig","component","CinePlayerComponent","CinePlayer","get","cineHandler","cine","frameRate","validFrameRate","Math","playClip","framesPerSecond","newStackCineHandler","viewports","displaySetInstanceUIDs","forEach","displaySetInstanceUID","displaySet","getDisplaySetByUID","FrameRate","round","autoPlayCine","setIsCineEnabled","eventTarget","STACK_VIEWPORT_NEW_STACK","onClose","handleCineClose","recordInteraction","groupId","interactionType","commands","commandName","commandOptions","toolName","context","onPlayPauseChange","onFrameRateChange","cacheJumpToMeasurementEvent","areEqual","prevProps","nextProps","needsRerendering","displaySets","orientation","toolGroupId","prevDisplaySets","nextDisplaySets","prevDisplaySet","foundDisplaySet","find","nextDisplaySet","images","j","OHIFCornerstoneViewport","dataSource","displaySetOptions","commandsManager","onElementEnabled","onElementDisabled","isJumpToMeasurementDisabled","initialImageIndex","setScrollbarHeight","setEnabledVPElement","elementRef","measurementService","toolGroupService","syncGroupService","cornerstoneCacheService","stateSyncService","viewportDialogState","useViewportDialog","setImageScrollBarHeight","onResize","resize","cleanUpServices","renderingEngineId","getRenderingEngineId","syncGroups","getSyncGroups","removeViewportFromToolGroup","removeViewportFromSyncGroup","elementEnabledHandler","setEnabledElement","getToolGroupId","addViewportToToolGroup","addViewportToSyncGroup","synchronizersStore","synchronizerObj","sourceViewports","targetViewports","synchronizer","getSynchronizer","sourceViewportInfo","sourceViewport","targetViewportInfo","targetViewport","isSourceViewportInSynchronizer","getSourceViewports","isTargetViewportInSynchronizer","getTargetViewports","addSource","addTarget","_rehydrateSynchronizers","enableViewport","ELEMENT_ENABLED","storePresentation","disableElement","DISPLAY_SET_SERIES_METADATA_INVALIDATED","async","invalidatedDisplaySetInstanceUID","invalidateData","hasDisplaySet","getViewportData","newViewportData","invalidateViewportData","keepCamera","updateViewport","createViewportData","lutPresentationStore","positionPresentationStore","presentationIds","presentations","positionPresentation","positionPresentationId","lutPresentation","lutPresentationId","measurement","cs3DTools","uid","loadViewportData","unsubscribeFromJumpToMeasurementEvents","MeasurementService","JUMP_TO_MEASUREMENT_VIEWPORT","jumpId","isConsumed","getViewportIdToJump","referencedImageId","_jumpToMeasurement","_subscribeToJumpToMeasurementEvents","displaysUIDs","includes","_checkForCachedJumpToMeasurementEvents","ReactResizeDetector","refreshMode","refreshRate","targetRef","width","onContextMenu","e","preventDefault","onMouseDown","ref","CornerstoneOverlays","toolBarService","Notification","message","type","actions","onSubmit","onOutsideClick","targetElementRef","targetElement","SOPInstanceUID","frameNumber","warn","referencedDisplaySet","setActiveViewportId","enabledElement","imageIdIndex","viewportCameraDirectionMatch","StackViewport","getImageIds","findIndex","aSOPInstanceUID","aFrameNumber","getSOPInstanceAttributes","measurementViewPlane","metadata","viewportViewPlane","abs","consume","displayName","initialImageIdOrIndex"],"sourceRoot":""}