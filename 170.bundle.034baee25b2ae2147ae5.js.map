{"version":3,"file":"170.bundle.034baee25b2ae2147ae5.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/id.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/constants/scoordTypes.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/DICOMSRDisplayTool.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/toolNames.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addMeasurement.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/isRehydratable.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getFilteredCornerstoneToolState.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/commandsModule.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addToolInstance.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/createReferencedImageDisplaySet.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/onModeEnter.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/init.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/modules/dicomSRModule.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/hydrateStructuredReport.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getLabelFromDCMJSImportedToolData.js"],"sourcesContent":["import packageJson from '../package.json';\n\nconst id = packageJson.name;\n\nconst SOPClassHandlerName = 'dicom-sr';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { SOPClassHandlerName, SOPClassHandlerId, id };\n","export default {\n  POINT: 'POINT',\n  MULTIPOINT: 'MULTIPOINT',\n  POLYLINE: 'POLYLINE',\n  CIRCLE: 'CIRCLE',\n  ELLIPSE: 'ELLIPSE',\n};\n","import { Types, metaData, utilities as csUtils } from '@cornerstonejs/core';\nimport {\n  AnnotationTool,\n  annotation,\n  drawing,\n  utilities,\n  Types as cs3DToolsTypes,\n} from '@cornerstonejs/tools';\nimport { getTrackingUniqueIdentifiersForElement } from './modules/dicomSRModule';\nimport SCOORD_TYPES from '../constants/scoordTypes';\n\nexport default class DICOMSRDisplayTool extends AnnotationTool {\n  static toolName = 'DICOMSRDisplay';\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _getTextBoxLinesFromLabels(labels) {\n    // TODO -> max 3 for now (label + shortAxis + longAxis), need a generic solution for this!\n\n    const labelLength = Math.min(labels.length, 3);\n    const lines = [];\n\n    for (let i = 0; i < labelLength; i++) {\n      const labelEntry = labels[i];\n      lines.push(`${_labelToShorthand(labelEntry.label)}${labelEntry.value}`);\n    }\n\n    return lines;\n  }\n\n  // This tool should not inherit from AnnotationTool and we should not need\n  // to add the following lines.\n  isPointNearTool = () => null;\n  getHandleNearImagePoint = () => null;\n\n  renderAnnotation = (enabledElement: Types.IEnabledElement, svgDrawingHelper: any): void => {\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = annotation.state.getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const trackingUniqueIdentifiersForElement = getTrackingUniqueIdentifiersForElement(element);\n\n    const { activeIndex, trackingUniqueIdentifiers } = trackingUniqueIdentifiersForElement;\n\n    const activeTrackingUniqueIdentifier = trackingUniqueIdentifiers[activeIndex];\n\n    // Filter toolData to only render the data for the active SR.\n    const filteredAnnotations = annotations.filter(annotation =>\n      trackingUniqueIdentifiers.includes(annotation.data?.cachedStats?.TrackingUniqueIdentifier)\n    );\n\n    if (!viewport._actors?.size) {\n      return;\n    }\n\n    const styleSpecifier: cs3DToolsTypes.AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < filteredAnnotations.length; i++) {\n      const annotation = filteredAnnotations[i];\n      const annotationUID = annotation.annotationUID;\n      const { renderableData } = annotation.data.cachedStats;\n      const { cachedStats } = annotation.data;\n      const { referencedImageId } = annotation.metadata;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color =\n        cachedStats.TrackingUniqueIdentifier === activeTrackingUniqueIdentifier\n          ? 'rgb(0, 255, 0)'\n          : this.getStyle('color', styleSpecifier, annotation);\n\n      const options = {\n        color,\n        lineDash,\n        lineWidth,\n      };\n\n      Object.keys(renderableData).forEach(GraphicType => {\n        const renderableDataForGraphicType = renderableData[GraphicType];\n\n        let renderMethod;\n        let canvasCoordinatesAdapter;\n\n        switch (GraphicType) {\n          case SCOORD_TYPES.POINT:\n            renderMethod = this.renderPoint;\n            break;\n          case SCOORD_TYPES.MULTIPOINT:\n            renderMethod = this.renderMultipoint;\n            break;\n          case SCOORD_TYPES.POLYLINE:\n            renderMethod = this.renderPolyLine;\n            break;\n          case SCOORD_TYPES.CIRCLE:\n            renderMethod = this.renderEllipse;\n            break;\n          case SCOORD_TYPES.ELLIPSE:\n            renderMethod = this.renderEllipse;\n            canvasCoordinatesAdapter = utilities.math.ellipse.getCanvasEllipseCorners;\n            break;\n          default:\n            throw new Error(`Unsupported GraphicType: ${GraphicType}`);\n        }\n\n        const canvasCoordinates = renderMethod(\n          svgDrawingHelper,\n          viewport,\n          renderableDataForGraphicType,\n          annotationUID,\n          referencedImageId,\n          options\n        );\n\n        this.renderTextBox(\n          svgDrawingHelper,\n          viewport,\n          canvasCoordinates,\n          canvasCoordinatesAdapter,\n          annotation,\n          styleSpecifier,\n          options\n        );\n      });\n    }\n  };\n\n  renderPolyLine(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    const drawingOptions = {\n      color: options.color,\n      width: options.lineWidth,\n    };\n    let allCanvasCoordinates = [];\n    renderableData.map((data, index) => {\n      const canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\n      const lineUID = `${index}`;\n\n      if (canvasCoordinates.length === 2) {\n        drawing.drawLine(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          drawingOptions\n        );\n      } else {\n        drawing.drawPolyline(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates,\n          drawingOptions\n        );\n      }\n\n      allCanvasCoordinates = allCanvasCoordinates.concat(canvasCoordinates);\n    });\n\n    return allCanvasCoordinates; // used for drawing textBox\n  }\n\n  renderMultipoint(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    let canvasCoordinates;\n    renderableData.map((data, index) => {\n      canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\n      const handleGroupUID = '0';\n      drawing.drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n        color: options.color,\n      });\n    });\n  }\n\n  renderPoint(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    const canvasCoordinates = [];\n    renderableData.map((data, index) => {\n      const point = data[0];\n      // This gives us one point for arrow\n      canvasCoordinates.push(viewport.worldToCanvas(point));\n\n      // We get the other point for the arrow by using the image size\n      const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\n\n      let xOffset = 10;\n      let yOffset = 10;\n\n      if (imagePixelModule) {\n        const { columns, rows } = imagePixelModule;\n        xOffset = columns / 10;\n        yOffset = rows / 10;\n      }\n\n      const imagePoint = csUtils.worldToImageCoords(referencedImageId, point);\n      const arrowEnd = csUtils.imageToWorldCoords(referencedImageId, [\n        imagePoint[0] + xOffset,\n        imagePoint[1] + yOffset,\n      ]);\n\n      canvasCoordinates.push(viewport.worldToCanvas(arrowEnd));\n\n      const arrowUID = `${index}`;\n\n      // Todo: handle drawing probe as probe, currently we are drawing it as an arrow\n      drawing.drawArrow(\n        svgDrawingHelper,\n        annotationUID,\n        arrowUID,\n        canvasCoordinates[1],\n        canvasCoordinates[0],\n        {\n          color: options.color,\n          width: options.lineWidth,\n        }\n      );\n    });\n\n    return canvasCoordinates; // used for drawing textBox\n  }\n\n  renderEllipse(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    let canvasCoordinates;\n    renderableData.map((data, index) => {\n      if (data.length === 0) {\n        // since oblique ellipse is not supported for hydration right now\n        // we just return\n        return;\n      }\n\n      const ellipsePointsWorld = data;\n\n      const rotation = viewport.getRotation();\n\n      canvasCoordinates = ellipsePointsWorld.map(p => viewport.worldToCanvas(p));\n      let canvasCorners;\n      if (rotation == 90 || rotation == 270) {\n        canvasCorners = utilities.math.ellipse.getCanvasEllipseCorners([\n          canvasCoordinates[2],\n          canvasCoordinates[3],\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n        ]) as Array<Types.Point2>;\n      } else {\n        canvasCorners = utilities.math.ellipse.getCanvasEllipseCorners(\n          canvasCoordinates\n        ) as Array<Types.Point2>;\n      }\n\n      const lineUID = `${index}`;\n      drawing.drawEllipse(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCorners[0],\n        canvasCorners[1],\n        {\n          color: options.color,\n          width: options.lineWidth,\n        }\n      );\n    });\n\n    return canvasCoordinates;\n  }\n\n  renderTextBox(\n    svgDrawingHelper,\n    viewport,\n    canvasCoordinates,\n    canvasCoordinatesAdapter,\n    annotation,\n    styleSpecifier,\n    options = {}\n  ) {\n    if (!canvasCoordinates || !annotation) {\n      return;\n    }\n\n    const { annotationUID, data = {} } = annotation;\n    const { label } = data;\n    const { color } = options;\n\n    let adaptedCanvasCoordinates = canvasCoordinates;\n    // adapt coordinates if there is an adapter\n    if (typeof canvasCoordinatesAdapter === 'function') {\n      adaptedCanvasCoordinates = canvasCoordinatesAdapter(canvasCoordinates);\n    }\n    const textLines = this._getTextBoxLinesFromLabels(label);\n    const canvasTextBoxCoords = utilities.drawing.getTextBoxCoordsCanvas(adaptedCanvasCoordinates);\n\n    if (!annotation.data?.handles?.textBox?.worldPosition) {\n      annotation.data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(annotation.data.handles.textBox.worldPosition);\n\n    const textBoxUID = '1';\n    const textBoxOptions = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    const boundingBox = drawing.drawLinkedTextBox(\n      svgDrawingHelper,\n      annotationUID,\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      {\n        ...textBoxOptions,\n        color,\n      }\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    annotation.data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  }\n}\n\nconst SHORT_HAND_MAP = {\n  'Short Axis': 'W: ',\n  'Long Axis': 'L: ',\n  AREA: 'Area: ',\n  Length: '',\n  CORNERSTONEFREETEXT: '',\n};\n\nfunction _labelToShorthand(label) {\n  const shortHand = SHORT_HAND_MAP[label];\n\n  if (shortHand !== undefined) {\n    return shortHand;\n  }\n\n  return label;\n}\n","import DICOMSRDisplayTool from './DICOMSRDisplayTool';\n\nconst toolNames = {\n  DICOMSRDisplay: DICOMSRDisplayTool.toolName,\n  SRLength: 'SRLength',\n  SRBidirectional: 'SRBidirectional',\n  SREllipticalROI: 'SREllipticalROI',\n  SRCircleROI: 'SRCircleROI',\n  SRArrowAnnotate: 'SRArrowAnnotate',\n  SRAngle: 'SRAngle',\n  SRCobbAngle: 'SRCobbAngle',\n  SRRectangleROI: 'SRRectangleROI',\n  SRPlanarFreehandROI: 'SRPlanarFreehandROI',\n};\n\nexport default toolNames;\n","import { vec3 } from 'gl-matrix';\nimport { Types, annotation } from '@cornerstonejs/tools';\nimport { metaData, utilities, Types as csTypes } from '@cornerstonejs/core';\nimport toolNames from '../tools/toolNames';\nimport SCOORD_TYPES from '../constants/scoordTypes';\n\nconst EPSILON = 1e-4;\n\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\n\nexport default function addMeasurement(measurement, imageId, displaySetInstanceUID) {\n  // TODO -> Render rotated ellipse .\n  const toolName = toolNames.DICOMSRDisplay;\n\n  const measurementData = {\n    TrackingUniqueIdentifier: measurement.TrackingUniqueIdentifier,\n    renderableData: {},\n    labels: measurement.labels,\n    imageId,\n  };\n\n  measurement.coords.forEach(coord => {\n    const { GraphicType, GraphicData } = coord;\n\n    if (measurementData.renderableData[GraphicType] === undefined) {\n      measurementData.renderableData[GraphicType] = [];\n    }\n\n    measurementData.renderableData[GraphicType].push(\n      _getRenderableData(GraphicType, GraphicData, imageId, measurement.TrackingIdentifier)\n    );\n  });\n\n  // Use the metadata provider to grab its imagePlaneModule metadata\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n  const annotationManager = annotation.state.getAnnotationManager();\n\n  // Create Cornerstone3D Annotation from measurement\n  const frameNumber =\n    (measurement.coords[0].ReferencedSOPSequence &&\n      measurement.coords[0].ReferencedSOPSequence[0]?.ReferencedFrameNumber) ||\n    1;\n\n  const SRAnnotation: Types.Annotation = {\n    annotationUID: measurement.TrackingUniqueIdentifier,\n    metadata: {\n      FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n      toolName: toolName,\n      referencedImageId: imageId,\n    },\n    data: {\n      label: measurement.labels,\n      handles: {\n        textBox: measurement.textBox ?? {},\n      },\n      cachedStats: {\n        TrackingUniqueIdentifier: measurementData.TrackingUniqueIdentifier,\n        renderableData: measurementData.renderableData,\n      },\n      frameNumber: frameNumber,\n    },\n  };\n\n  annotationManager.addAnnotation(SRAnnotation);\n\n  measurement.loaded = true;\n  measurement.imageId = imageId;\n  measurement.displaySetInstanceUID = displaySetInstanceUID;\n\n  // Remove the unneeded coord now its processed, but keep the SOPInstanceUID.\n  // NOTE: We assume that each SCOORD in the MeasurementGroup maps onto one frame,\n  // It'd be super weird if it didn't anyway as a SCOORD.\n  measurement.ReferencedSOPInstanceUID =\n    measurement.coords[0].ReferencedSOPSequence.ReferencedSOPInstanceUID;\n  measurement.frameNumber = frameNumber;\n  delete measurement.coords;\n}\n\nfunction _getRenderableData(GraphicType, GraphicData, imageId, TrackingIdentifier) {\n  const [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\n\n  let renderableData: csTypes.Point3[];\n\n  switch (GraphicType) {\n    case SCOORD_TYPES.POINT:\n    case SCOORD_TYPES.MULTIPOINT:\n    case SCOORD_TYPES.POLYLINE:\n      renderableData = [];\n\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const worldPos = utilities.imageToWorldCoords(imageId, [\n          GraphicData[i],\n          GraphicData[i + 1],\n        ]);\n\n        renderableData.push(worldPos);\n      }\n\n      break;\n    case SCOORD_TYPES.CIRCLE: {\n      const pointsWorld = [];\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const worldPos = utilities.imageToWorldCoords(imageId, [\n          GraphicData[i],\n          GraphicData[i + 1],\n        ]);\n\n        pointsWorld.push(worldPos);\n      }\n\n      // We do not have an explicit draw circle svg helper in Cornerstone3D at\n      // this time, but we can use the ellipse svg helper to draw a circle, so\n      // here we reshape the data for that purpose.\n      const center = pointsWorld[0];\n      const onPerimeter = pointsWorld[1];\n\n      const radius = vec3.distance(center, onPerimeter);\n\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n      if (!imagePlaneModule) {\n        throw new Error('No imagePlaneModule found');\n      }\n\n      const {\n        columnCosines,\n        rowCosines,\n      }: {\n        columnCosines: csTypes.Point3;\n        rowCosines: csTypes.Point3;\n      } = imagePlaneModule;\n\n      // we need to get major/minor axis (which are both the same size major = minor)\n\n      // first axisStart\n      const firstAxisStart = vec3.create();\n      vec3.scaleAndAdd(firstAxisStart, center, columnCosines, radius);\n\n      const firstAxisEnd = vec3.create();\n      vec3.scaleAndAdd(firstAxisEnd, center, columnCosines, -radius);\n\n      // second axisStart\n      const secondAxisStart = vec3.create();\n      vec3.scaleAndAdd(secondAxisStart, center, rowCosines, radius);\n\n      const secondAxisEnd = vec3.create();\n      vec3.scaleAndAdd(secondAxisEnd, center, rowCosines, -radius);\n\n      renderableData = [\n        firstAxisStart as csTypes.Point3,\n        firstAxisEnd as csTypes.Point3,\n        secondAxisStart as csTypes.Point3,\n        secondAxisEnd as csTypes.Point3,\n      ];\n\n      break;\n    }\n    case SCOORD_TYPES.ELLIPSE: {\n      // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\n      // But Cornerstone3D points are ordered as top, bottom, left, right for the\n      // ellipse so we need to identify if the majorAxis is horizontal or vertical\n      // and then choose the correct points to use for the ellipse.\n\n      const pointsWorld: csTypes.Point3[] = [];\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const worldPos = utilities.imageToWorldCoords(imageId, [\n          GraphicData[i],\n          GraphicData[i + 1],\n        ]);\n\n        pointsWorld.push(worldPos);\n      }\n\n      const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n      const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n      const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n      const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n\n      const majorAxisVec = vec3.create();\n      vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n\n      // normalize majorAxisVec to avoid scaling issues\n      vec3.normalize(majorAxisVec, majorAxisVec);\n\n      const minorAxisVec = vec3.create();\n      vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n      vec3.normalize(minorAxisVec, minorAxisVec);\n\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n      if (!imagePlaneModule) {\n        throw new Error('imageId does not have imagePlaneModule metadata');\n      }\n\n      const { columnCosines }: { columnCosines: csTypes.Point3 } = imagePlaneModule;\n\n      // find which axis is parallel to the columnCosines\n      const columnCosinesVec = vec3.fromValues(...columnCosines);\n\n      const projectedMajorAxisOnColVec = Math.abs(vec3.dot(columnCosinesVec, majorAxisVec));\n      const projectedMinorAxisOnColVec = Math.abs(vec3.dot(columnCosinesVec, minorAxisVec));\n\n      const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n      const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n\n      renderableData = [];\n      if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n        renderableData = [pointsWorld[0], pointsWorld[1], pointsWorld[2], pointsWorld[3]];\n      } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n        renderableData = [pointsWorld[2], pointsWorld[3], pointsWorld[0], pointsWorld[1]];\n      } else {\n        console.warn('OBLIQUE ELLIPSE NOT YET SUPPORTED');\n      }\n      break;\n    }\n    default:\n      console.warn('Unsupported GraphicType:', GraphicType);\n  }\n\n  return renderableData;\n}\n","import { adaptersSR } from '@cornerstonejs/adapters';\n\nconst cornerstoneAdapters =\n  adaptersSR.Cornerstone3D.MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\nconst CORNERSTONE_3D_TAG = cornerstoneAdapters.CORNERSTONE_3D_TAG;\n\n/**\n * Checks if the given `displaySet`can be rehydrated into the `measurementService`.\n *\n * @param {object} displaySet The SR `displaySet` to check.\n * @param {object[]} mappings The CornerstoneTools 4 mappings to the `measurementService`.\n * @returns {boolean} True if the SR can be rehydrated into the `measurementService`.\n */\nexport default function isRehydratable(displaySet, mappings) {\n  if (!mappings || !mappings.length) {\n    return false;\n  }\n\n  const mappingDefinitions = mappings.map(m => m.annotationType);\n  const { measurements } = displaySet;\n\n  const adapterKeys = Object.keys(cornerstoneAdapters).filter(\n    adapterKey =>\n      typeof cornerstoneAdapters[adapterKey].isValidCornerstoneTrackingIdentifier === 'function'\n  );\n\n  const adapters = [];\n\n  adapterKeys.forEach(key => {\n    if (mappingDefinitions.includes(key)) {\n      // Must have both a dcmjs adapter and a measurementService\n      // Definition in order to be a candidate for import.\n      adapters.push(cornerstoneAdapters[key]);\n    }\n  });\n\n  for (let i = 0; i < measurements.length; i++) {\n    const { TrackingIdentifier } = measurements[i] || {};\n    const hydratable = adapters.some(adapter => {\n      let [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\n      if (supportedLegacyCornerstoneTags.includes(cornerstoneTag)) {\n        cornerstoneTag = CORNERSTONE_3D_TAG;\n      }\n\n      const mappedTrackingIdentifier = `${cornerstoneTag}:${toolName}`;\n\n      return adapter.isValidCornerstoneTrackingIdentifier(mappedTrackingIdentifier);\n    });\n\n    if (hydratable) {\n      return true;\n    }\n    console.log('Measurement is not rehydratable', TrackingIdentifier, measurements[i]);\n  }\n\n  console.log('No measurements found which were rehydratable');\n  return false;\n}\n","import { SOPClassHandlerName, SOPClassHandlerId } from './id';\nimport { utils, classes, DisplaySetService, Types } from '@ohif/core';\nimport addMeasurement from './utils/addMeasurement';\nimport isRehydratable from './utils/isRehydratable';\nimport { adaptersSR } from '@cornerstonejs/adapters';\n\ntype InstanceMetadata = Types.InstanceMetadata;\n\nconst { CodeScheme: Cornerstone3DCodeScheme } = adaptersSR.Cornerstone3D;\n\nconst { ImageSet, MetadataProvider: metadataProvider } = classes;\n\n// TODO ->\n// Add SR thumbnail\n// Make viewport\n// Get stacks from referenced displayInstanceUID and load into wrapped CornerStone viewport.\n\nconst sopClassUids = [\n  '1.2.840.10008.5.1.4.1.1.88.11', //BASIC_TEXT_SR:\n  '1.2.840.10008.5.1.4.1.1.88.22', //ENHANCED_SR:\n  '1.2.840.10008.5.1.4.1.1.88.33', //COMPREHENSIVE_SR:\n  '1.2.840.10008.5.1.4.1.1.88.34', //COMPREHENSIVE_3D_SR:\n];\n\nconst CORNERSTONE_3D_TOOLS_SOURCE_NAME = 'Cornerstone3DTools';\nconst CORNERSTONE_3D_TOOLS_SOURCE_VERSION = '0.1';\n\nconst validateSameStudyUID = (uid: string, instances): void => {\n  instances.forEach(it => {\n    if (it.StudyInstanceUID !== uid) {\n      console.warn('Not all instances have the same UID', uid, it);\n      throw new Error(`Instances ${it.SOPInstanceUID} does not belong to ${uid}`);\n    }\n  });\n};\n\nconst CodeNameCodeSequenceValues = {\n  ImagingMeasurementReport: '126000',\n  ImageLibrary: '111028',\n  ImagingMeasurements: '126010',\n  MeasurementGroup: '125007',\n  ImageLibraryGroup: '126200',\n  TrackingUniqueIdentifier: '112040',\n  TrackingIdentifier: '112039',\n  Finding: '121071',\n  FindingSite: 'G-C0E3', // SRT\n  CornerstoneFreeText: Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT, //\n};\n\nconst CodingSchemeDesignators = {\n  SRT: 'SRT',\n  CornerstoneCodeSchemes: [Cornerstone3DCodeScheme.CodingSchemeDesignator, 'CST4'],\n};\n\nconst RELATIONSHIP_TYPE = {\n  INFERRED_FROM: 'INFERRED FROM',\n  CONTAINS: 'CONTAINS',\n};\n\nconst CORNERSTONE_FREETEXT_CODE_VALUE = 'CORNERSTONEFREETEXT';\n\n/**\n * Adds instances to the DICOM SR series, rather than creating a new\n * series, so that as SR's are saved, they append to the series, and the\n * key image display set gets updated as well, containing just the new series.\n * @param instances is a list of instances from THIS series that are not\n *     in this DICOM SR Display Set already.\n */\nfunction addInstances(instances: InstanceMetadata[], displaySetService: DisplaySetService) {\n  this.instances.push(...instances);\n  utils.sortStudyInstances(this.instances);\n  // The last instance is the newest one, so is the one most interesting.\n  // Eventually, the SR viewer should have the ability to choose which SR\n  // gets loaded, and to navigate among them.\n  this.instance = this.instances[this.instances.length - 1];\n  this.isLoaded = false;\n  return this;\n}\n\n/**\n * DICOM SR SOP Class Handler\n * For all referenced images in the TID 1500/300 sections, add an image to the\n * display.\n * @param instances is a set of instances all from the same series\n * @param servicesManager is the services that can be used for creating\n * @returns The list of display sets created for the given instances object\n */\nfunction _getDisplaySetsFromSeries(instances, servicesManager, extensionManager) {\n  // If the series has no instances, stop here\n  if (!instances || !instances.length) {\n    throw new Error('No instances were provided');\n  }\n\n  utils.sortStudyInstances(instances);\n  // The last instance is the newest one, so is the one most interesting.\n  // Eventually, the SR viewer should have the ability to choose which SR\n  // gets loaded, and to navigate among them.\n  const instance = instances[instances.length - 1];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    ConceptNameCodeSequence,\n    SOPClassUID,\n  } = instance;\n  validateSameStudyUID(instance.StudyInstanceUID, instances);\n\n  if (\n    !ConceptNameCodeSequence ||\n    ConceptNameCodeSequence.CodeValue !== CodeNameCodeSequenceValues.ImagingMeasurementReport\n  ) {\n    servicesManager.services.uiNotificationService.show({\n      title: 'DICOM SR',\n      message:\n        'OHIF only supports TID1500 Imaging Measurement Report Structured Reports. The SR you’re trying to view is not supported.',\n      type: 'warning',\n      duration: 6000,\n    });\n    return [];\n  }\n\n  const displaySet = {\n    //plugin: id,\n    Modality: 'SR',\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    instances,\n    referencedImages: null,\n    measurements: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    sopClassUids,\n    instance,\n    addInstances,\n  };\n\n  displaySet.load = () => _load(displaySet, servicesManager, extensionManager);\n\n  return [displaySet];\n}\n\nfunction _load(displaySet, servicesManager, extensionManager) {\n  const { displaySetService, measurementService } = servicesManager.services;\n  const dataSources = extensionManager.getDataSources();\n  const dataSource = dataSources[0];\n\n  const { ContentSequence } = displaySet.instance;\n\n  displaySet.referencedImages = _getReferencedImagesList(ContentSequence);\n  displaySet.measurements = _getMeasurements(ContentSequence);\n\n  const mappings = measurementService.getSourceMappings(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  displaySet.isHydrated = false;\n  displaySet.isRehydratable = isRehydratable(displaySet, mappings);\n  displaySet.isLoaded = true;\n\n  // Check currently added displaySets and add measurements if the sources exist.\n  displaySetService.activeDisplaySets.forEach(activeDisplaySet => {\n    _checkIfCanAddMeasurementsToDisplaySet(\n      displaySet,\n      activeDisplaySet,\n      dataSource,\n      servicesManager\n    );\n  });\n\n  // Subscribe to new displaySets as the source may come in after.\n  displaySetService.subscribe(displaySetService.EVENTS.DISPLAY_SETS_ADDED, data => {\n    const { displaySetsAdded } = data;\n    // If there are still some measurements that have not yet been loaded into cornerstone,\n    // See if we can load them onto any of the new displaySets.\n    displaySetsAdded.forEach(newDisplaySet => {\n      _checkIfCanAddMeasurementsToDisplaySet(\n        displaySet,\n        newDisplaySet,\n        dataSource,\n        servicesManager\n      );\n    });\n  });\n}\n\nfunction _checkIfCanAddMeasurementsToDisplaySet(\n  srDisplaySet,\n  newDisplaySet,\n  dataSource,\n  servicesManager\n) {\n  const { customizationService } = servicesManager.services;\n  let unloadedMeasurements = srDisplaySet.measurements.filter(\n    measurement => measurement.loaded === false\n  );\n\n  if (unloadedMeasurements.length === 0) {\n    // All already loaded!\n    return;\n  }\n\n  if (!newDisplaySet instanceof ImageSet) {\n    // This also filters out _this_ displaySet, as it is not an ImageSet.\n    return;\n  }\n\n  if (newDisplaySet.unsupported) {\n    return;\n  }\n\n  const { sopClassUids } = newDisplaySet;\n\n  // Check if any have the newDisplaySet is the correct SOPClass.\n  unloadedMeasurements = unloadedMeasurements.filter(measurement =>\n    measurement.coords.some(coord =>\n      sopClassUids.includes(coord.ReferencedSOPSequence.ReferencedSOPClassUID)\n    )\n  );\n\n  if (unloadedMeasurements.length === 0) {\n    // New displaySet isn't the correct SOPClass, so can't contain the referenced images.\n    return;\n  }\n\n  const SOPInstanceUIDs = [];\n\n  unloadedMeasurements.forEach(measurement => {\n    const { coords } = measurement;\n\n    coords.forEach(coord => {\n      const SOPInstanceUID = coord.ReferencedSOPSequence.ReferencedSOPInstanceUID;\n\n      if (!SOPInstanceUIDs.includes(SOPInstanceUID)) {\n        SOPInstanceUIDs.push(SOPInstanceUID);\n      }\n    });\n  });\n\n  const imageIdsForDisplaySet = dataSource.getImageIdsForDisplaySet(newDisplaySet);\n\n  for (const imageId of imageIdsForDisplaySet) {\n    if (!unloadedMeasurements.length) {\n      // All measurements loaded.\n      return;\n    }\n\n    const { SOPInstanceUID, frameNumber } = metadataProvider.getUIDsFromImageID(imageId);\n\n    if (SOPInstanceUIDs.includes(SOPInstanceUID)) {\n      for (let j = unloadedMeasurements.length - 1; j >= 0; j--) {\n        let measurement = unloadedMeasurements[j];\n\n        const onBeforeSRAddMeasurement = customizationService.getModeCustomization(\n          'onBeforeSRAddMeasurement'\n        )?.value;\n\n        if (typeof onBeforeSRAddMeasurement === 'function') {\n          measurement = onBeforeSRAddMeasurement({\n            measurement,\n            StudyInstanceUID: srDisplaySet.StudyInstanceUID,\n            SeriesInstanceUID: srDisplaySet.SeriesInstanceUID,\n          });\n        }\n\n        if (_measurementReferencesSOPInstanceUID(measurement, SOPInstanceUID, frameNumber)) {\n          addMeasurement(measurement, imageId, newDisplaySet.displaySetInstanceUID);\n\n          unloadedMeasurements.splice(j, 1);\n        }\n      }\n    }\n  }\n}\n\nfunction _measurementReferencesSOPInstanceUID(measurement, SOPInstanceUID, frameNumber) {\n  const { coords } = measurement;\n\n  // NOTE: The ReferencedFrameNumber can be multiple values according to the DICOM\n  //  Standard. But for now, we will support only one ReferenceFrameNumber.\n  const ReferencedFrameNumber =\n    (measurement.coords[0].ReferencedSOPSequence &&\n      measurement.coords[0].ReferencedSOPSequence[0]?.ReferencedFrameNumber) ||\n    1;\n\n  if (frameNumber && Number(frameNumber) !== Number(ReferencedFrameNumber)) {\n    return false;\n  }\n\n  for (let j = 0; j < coords.length; j++) {\n    const coord = coords[j];\n    const { ReferencedSOPInstanceUID } = coord.ReferencedSOPSequence;\n\n    if (ReferencedSOPInstanceUID === SOPInstanceUID) {\n      return true;\n    }\n  }\n}\n\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\n  };\n\n  return [\n    {\n      name: SOPClassHandlerName,\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nfunction _getMeasurements(ImagingMeasurementReportContentSequence) {\n  const ImagingMeasurements = ImagingMeasurementReportContentSequence.find(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImagingMeasurements\n  );\n\n  const MeasurementGroups = _getSequenceAsArray(ImagingMeasurements.ContentSequence).filter(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.MeasurementGroup\n  );\n\n  const mergedContentSequencesByTrackingUniqueIdentifiers =\n    _getMergedContentSequencesByTrackingUniqueIdentifiers(MeasurementGroups);\n\n  const measurements = [];\n\n  Object.keys(mergedContentSequencesByTrackingUniqueIdentifiers).forEach(\n    trackingUniqueIdentifier => {\n      const mergedContentSequence =\n        mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier];\n\n      const measurement = _processMeasurement(mergedContentSequence);\n\n      if (measurement) {\n        measurements.push(measurement);\n      }\n    }\n  );\n\n  return measurements;\n}\n\nfunction _getMergedContentSequencesByTrackingUniqueIdentifiers(MeasurementGroups) {\n  const mergedContentSequencesByTrackingUniqueIdentifiers = {};\n\n  MeasurementGroups.forEach(MeasurementGroup => {\n    const ContentSequence = _getSequenceAsArray(MeasurementGroup.ContentSequence);\n\n    const TrackingUniqueIdentifierItem = ContentSequence.find(\n      item =>\n        item.ConceptNameCodeSequence.CodeValue ===\n        CodeNameCodeSequenceValues.TrackingUniqueIdentifier\n    );\n\n    if (!TrackingUniqueIdentifierItem) {\n      console.warn('No Tracking Unique Identifier, skipping ambiguous measurement.');\n    }\n\n    const trackingUniqueIdentifier = TrackingUniqueIdentifierItem.UID;\n\n    if (mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier] === undefined) {\n      // Add the full ContentSequence\n      mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier] = [\n        ...ContentSequence,\n      ];\n    } else {\n      // Add the ContentSequence minus the tracking identifier, as we have this\n      // Information in the merged ContentSequence anyway.\n      ContentSequence.forEach(item => {\n        if (\n          item.ConceptNameCodeSequence.CodeValue !==\n          CodeNameCodeSequenceValues.TrackingUniqueIdentifier\n        ) {\n          mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier].push(item);\n        }\n      });\n    }\n  });\n\n  return mergedContentSequencesByTrackingUniqueIdentifiers;\n}\n\nfunction _processMeasurement(mergedContentSequence) {\n  if (\n    mergedContentSequence.some(\n      group => group.ValueType === 'SCOORD' || group.ValueType === 'SCOORD3D'\n    )\n  ) {\n    return _processTID1410Measurement(mergedContentSequence);\n  }\n\n  return _processNonGeometricallyDefinedMeasurement(mergedContentSequence);\n}\n\nfunction _processTID1410Measurement(mergedContentSequence) {\n  // Need to deal with TID 1410 style measurements, which will have a SCOORD or SCOORD3D at the top level,\n  // And non-geometric representations where each NUM has \"INFERRED FROM\" SCOORD/SCOORD3D\n\n  const graphicItem = mergedContentSequence.find(group => group.ValueType === 'SCOORD');\n\n  const UIDREFContentItem = mergedContentSequence.find(group => group.ValueType === 'UIDREF');\n\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.TrackingIdentifier\n  );\n\n  if (!graphicItem) {\n    console.warn(\n      `graphic ValueType ${graphicItem.ValueType} not currently supported, skipping annotation.`\n    );\n    return;\n  }\n\n  const NUMContentItems = mergedContentSequence.filter(group => group.ValueType === 'NUM');\n\n  const measurement = {\n    loaded: false,\n    labels: [],\n    coords: [_getCoordsFromSCOORDOrSCOORD3D(graphicItem)],\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\n  };\n\n  NUMContentItems.forEach(item => {\n    const { ConceptNameCodeSequence, MeasuredValueSequence } = item;\n\n    if (MeasuredValueSequence) {\n      measurement.labels.push(\n        _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence)\n      );\n    }\n  });\n\n  return measurement;\n}\n\nfunction _processNonGeometricallyDefinedMeasurement(mergedContentSequence) {\n  const NUMContentItems = mergedContentSequence.filter(group => group.ValueType === 'NUM');\n\n  const UIDREFContentItem = mergedContentSequence.find(group => group.ValueType === 'UIDREF');\n\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.TrackingIdentifier\n  );\n\n  const finding = mergedContentSequence.find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.Finding\n  );\n\n  const findingSites = mergedContentSequence.filter(\n    item =>\n      item.ConceptNameCodeSequence.CodingSchemeDesignator === CodingSchemeDesignators.SRT &&\n      item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.FindingSite\n  );\n\n  const measurement = {\n    loaded: false,\n    labels: [],\n    coords: [],\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\n  };\n\n  if (\n    finding &&\n    CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\n      finding.ConceptCodeSequence.CodingSchemeDesignator\n    ) &&\n    finding.ConceptCodeSequence.CodeValue === CodeNameCodeSequenceValues.CornerstoneFreeText\n  ) {\n    measurement.labels.push({\n      label: CORNERSTONE_FREETEXT_CODE_VALUE,\n      value: finding.ConceptCodeSequence.CodeMeaning,\n    });\n  }\n\n  // TODO -> Eventually hopefully support SNOMED or some proper code library, just free text for now.\n  if (findingSites.length) {\n    const cornerstoneFreeTextFindingSite = findingSites.find(\n      FindingSite =>\n        CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\n          FindingSite.ConceptCodeSequence.CodingSchemeDesignator\n        ) &&\n        FindingSite.ConceptCodeSequence.CodeValue === CodeNameCodeSequenceValues.CornerstoneFreeText\n    );\n\n    if (cornerstoneFreeTextFindingSite) {\n      measurement.labels.push({\n        label: CORNERSTONE_FREETEXT_CODE_VALUE,\n        value: cornerstoneFreeTextFindingSite.ConceptCodeSequence.CodeMeaning,\n      });\n    }\n  }\n\n  NUMContentItems.forEach(item => {\n    const { ConceptNameCodeSequence, ContentSequence, MeasuredValueSequence } = item;\n\n    const { ValueType } = ContentSequence;\n\n    if (!ValueType === 'SCOORD') {\n      console.warn(`Graphic ${ValueType} not currently supported, skipping annotation.`);\n\n      return;\n    }\n\n    const coords = _getCoordsFromSCOORDOrSCOORD3D(ContentSequence);\n\n    if (coords) {\n      measurement.coords.push(coords);\n    }\n\n    if (MeasuredValueSequence) {\n      measurement.labels.push(\n        _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence)\n      );\n    }\n  });\n\n  return measurement;\n}\n\nfunction _getCoordsFromSCOORDOrSCOORD3D(item) {\n  const { ValueType, RelationshipType, GraphicType, GraphicData } = item;\n\n  if (\n    !(\n      RelationshipType == RELATIONSHIP_TYPE.INFERRED_FROM ||\n      RelationshipType == RELATIONSHIP_TYPE.CONTAINS\n    )\n  ) {\n    console.warn(\n      `Relationshiptype === ${RelationshipType}. Cannot deal with NON TID-1400 SCOORD group with RelationshipType !== \"INFERRED FROM\" or \"CONTAINS\"`\n    );\n\n    return;\n  }\n\n  const coords = { ValueType, GraphicType, GraphicData };\n\n  // ContentSequence has length of 1 as RelationshipType === 'INFERRED FROM'\n  if (ValueType === 'SCOORD') {\n    const { ReferencedSOPSequence } = item.ContentSequence;\n\n    coords.ReferencedSOPSequence = ReferencedSOPSequence;\n  } else if (ValueType === 'SCOORD3D') {\n    const { ReferencedFrameOfReferenceSequence } = item.ContentSequence;\n\n    coords.ReferencedFrameOfReferenceSequence = ReferencedFrameOfReferenceSequence;\n  }\n\n  return coords;\n}\n\nfunction _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence) {\n  const { CodeMeaning } = ConceptNameCodeSequence;\n  const { NumericValue, MeasurementUnitsCodeSequence } = MeasuredValueSequence;\n  const { CodeValue } = MeasurementUnitsCodeSequence;\n\n  const formatedNumericValue = NumericValue ? Number(NumericValue).toFixed(2) : '';\n\n  return {\n    label: CodeMeaning,\n    value: `${formatedNumericValue} ${CodeValue}`,\n  }; // E.g. Long Axis: 31.0 mm\n}\n\nfunction _getReferencedImagesList(ImagingMeasurementReportContentSequence) {\n  const ImageLibrary = ImagingMeasurementReportContentSequence.find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImageLibrary\n  );\n\n  const ImageLibraryGroup = _getSequenceAsArray(ImageLibrary.ContentSequence).find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImageLibraryGroup\n  );\n\n  const referencedImages = [];\n\n  _getSequenceAsArray(ImageLibraryGroup.ContentSequence).forEach(item => {\n    const { ReferencedSOPSequence } = item;\n    if (!ReferencedSOPSequence) {\n      return;\n    }\n    for (const ref of _getSequenceAsArray(ReferencedSOPSequence)) {\n      if (ref.ReferencedSOPClassUID) {\n        const { ReferencedSOPClassUID, ReferencedSOPInstanceUID } = ref;\n\n        referencedImages.push({\n          ReferencedSOPClassUID,\n          ReferencedSOPInstanceUID,\n        });\n      }\n    }\n  });\n\n  return referencedImages;\n}\n\nfunction _getSequenceAsArray(sequence) {\n  if (!sequence) {\n    return [];\n  }\n  return Array.isArray(sequence) ? sequence : [sequence];\n}\n\nexport default getSopClassHandlerModule;\n","import { Types } from '@ohif/core';\n\nconst srProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/sr',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  name: 'SR Key Images',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'srDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    srDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SR',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'SR Key Images',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: { allowUnmatchedView: true },\n          displaySets: [\n            {\n              id: 'srDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: srProtocol.id,\n      protocol: srProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { srProtocol };\n","import OHIF from '@ohif/core';\nimport { annotation } from '@cornerstonejs/tools';\nconst { log } = OHIF;\n\nfunction getFilteredCornerstoneToolState(measurementData, additionalFindingTypes) {\n  const filteredToolState = {};\n\n  function addToFilteredToolState(annotation, toolType) {\n    if (!annotation.metadata?.referencedImageId) {\n      log.warn(`[DICOMSR] No referencedImageId found for ${toolType} ${annotation.id}`);\n      return;\n    }\n\n    const imageId = annotation.metadata.referencedImageId;\n\n    if (!filteredToolState[imageId]) {\n      filteredToolState[imageId] = {};\n    }\n\n    const imageIdSpecificToolState = filteredToolState[imageId];\n\n    if (!imageIdSpecificToolState[toolType]) {\n      imageIdSpecificToolState[toolType] = {\n        data: [],\n      };\n    }\n\n    const measurementDataI = measurementData.find(md => md.uid === annotation.annotationUID);\n    const toolData = imageIdSpecificToolState[toolType].data;\n\n    let { finding } = measurementDataI;\n    const findingSites = [];\n\n    // NOTE -> We use the CORNERSTONEJS coding schemeDesignator which we have\n    // defined in the @cornerstonejs/adapters\n    if (measurementDataI.label) {\n      if (additionalFindingTypes.includes(toolType)) {\n        finding = {\n          CodeValue: 'CORNERSTONEFREETEXT',\n          CodingSchemeDesignator: 'CORNERSTONEJS',\n          CodeMeaning: measurementDataI.label,\n        };\n      } else {\n        findingSites.push({\n          CodeValue: 'CORNERSTONEFREETEXT',\n          CodingSchemeDesignator: 'CORNERSTONEJS',\n          CodeMeaning: measurementDataI.label,\n        });\n      }\n    }\n\n    if (measurementDataI.findingSites) {\n      findingSites.push(...measurementDataI.findingSites);\n    }\n\n    const measurement = Object.assign({}, annotation, {\n      finding,\n      findingSites,\n    });\n\n    toolData.push(measurement);\n  }\n\n  const uidFilter = measurementData.map(md => md.uid);\n  const uids = uidFilter.slice();\n\n  const annotationManager = annotation.state.getAnnotationManager();\n  const framesOfReference = annotationManager.getFramesOfReference();\n\n  for (let i = 0; i < framesOfReference.length; i++) {\n    const frameOfReference = framesOfReference[i];\n\n    const frameOfReferenceAnnotations = annotationManager.getAnnotations(frameOfReference);\n\n    const toolTypes = Object.keys(frameOfReferenceAnnotations);\n\n    for (let j = 0; j < toolTypes.length; j++) {\n      const toolType = toolTypes[j];\n\n      const annotations = frameOfReferenceAnnotations[toolType];\n\n      if (annotations) {\n        for (let k = 0; k < annotations.length; k++) {\n          const annotation = annotations[k];\n          const uidIndex = uids.findIndex(uid => uid === annotation.annotationUID);\n\n          if (uidIndex !== -1) {\n            addToFilteredToolState(annotation, toolType);\n            uids.splice(uidIndex, 1);\n\n            if (!uids.length) {\n              return filteredToolState;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return filteredToolState;\n}\n\nexport default getFilteredCornerstoneToolState;\n","import { metaData, utilities } from '@cornerstonejs/core';\n\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\nimport dcmjs from 'dcmjs';\nimport { adaptersSR } from '@cornerstonejs/adapters';\n\nimport getFilteredCornerstoneToolState from './utils/getFilteredCornerstoneToolState';\n\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\nconst { log } = OHIF;\n\n/**\n *\n * @param measurementData An array of measurements from the measurements service\n * that you wish to serialize.\n * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n *\n */\nconst _generateReport = (measurementData, additionalFindingTypes, options = {}) => {\n  const filteredToolState = getFilteredCornerstoneToolState(\n    measurementData,\n    additionalFindingTypes\n  );\n\n  const report = MeasurementReport.generateReport(\n    filteredToolState,\n    metaData,\n    utilities.worldToImageCoords,\n    options\n  );\n\n  const { dataset } = report;\n\n  // Set the default character set as UTF-8\n  // https://dicom.innolitics.com/ciods/nm-image/sop-common/00080005\n  if (typeof dataset.SpecificCharacterSet === 'undefined') {\n    dataset.SpecificCharacterSet = 'ISO_IR 192';\n  }\n  return dataset;\n};\n\nconst commandsModule = props => {\n  const { servicesManager } = props;\n  const { customizationService } = servicesManager.services;\n  const actions = {\n    /**\n     *\n     * @param measurementData An array of measurements from the measurements service\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n     * as opposed to Finding Sites.\n     * that you wish to serialize.\n     */\n    downloadReport: ({ measurementData, additionalFindingTypes, options = {} }) => {\n      const srDataset = actions.generateReport(measurementData, additionalFindingTypes, options);\n      const reportBlob = dcmjs.data.datasetToBlob(srDataset);\n\n      //Create a URL for the binary.\n      var objectUrl = URL.createObjectURL(reportBlob);\n      window.location.assign(objectUrl);\n    },\n\n    /**\n     *\n     * @param measurementData An array of measurements from the measurements service\n     * that you wish to serialize.\n     * @param dataSource The dataSource that you wish to use to persist the data.\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n     * @return The naturalized report\n     */\n    storeMeasurements: async ({\n      measurementData,\n      dataSource,\n      additionalFindingTypes,\n      options = {},\n    }) => {\n      // Use the @cornerstonejs adapter for converting to/from DICOM\n      // But it is good enough for now whilst we only have cornerstone as a datasource.\n      log.info('[DICOMSR] storeMeasurements');\n\n      if (!dataSource || !dataSource.store || !dataSource.store.dicom) {\n        log.error('[DICOMSR] datasource has no dataSource.store.dicom endpoint!');\n        return Promise.reject({});\n      }\n\n      try {\n        const naturalizedReport = _generateReport(measurementData, additionalFindingTypes, options);\n\n        const { StudyInstanceUID, ContentSequence } = naturalizedReport;\n        // The content sequence has 5 or more elements, of which\n        // the `[4]` element contains the annotation data, so this is\n        // checking that there is some annotation data present.\n        if (!ContentSequence?.[4].ContentSequence?.length) {\n          console.log('naturalizedReport missing imaging content', naturalizedReport);\n          throw new Error('Invalid report, no content');\n        }\n\n        const onBeforeDicomStore =\n          customizationService.getModeCustomization('onBeforeDicomStore')?.value;\n\n        let dicomDict;\n        if (typeof onBeforeDicomStore === 'function') {\n          dicomDict = onBeforeDicomStore({ measurementData, naturalizedReport });\n        }\n\n        await dataSource.store.dicom(naturalizedReport, null, dicomDict);\n\n        if (StudyInstanceUID) {\n          dataSource.deleteStudyMetadataPromise(StudyInstanceUID);\n        }\n\n        // The \"Mode\" route listens for DicomMetadataStore changes\n        // When a new instance is added, it listens and\n        // automatically calls makeDisplaySets\n        DicomMetadataStore.addInstances([naturalizedReport], true);\n\n        return naturalizedReport;\n      } catch (error) {\n        console.warn(error);\n        log.error(`[DICOMSR] Error while saving the measurements: ${error.message}`);\n        throw new Error(error.message || 'Error while saving the measurements.');\n      }\n    },\n  };\n\n  const definitions = {\n    downloadReport: {\n      commandFn: actions.downloadReport,\n      storeContexts: [],\n      options: {},\n    },\n    storeMeasurements: {\n      commandFn: actions.storeMeasurements,\n      storeContexts: [],\n      options: {},\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'CORNERSTONE_STRUCTURED_REPORT',\n  };\n};\n\nexport default commandsModule;\n","import { addTool } from '@cornerstonejs/tools';\n\nexport default function addToolInstance(name: string, toolClass, configuration?): void {\n  class InstanceClass extends toolClass {\n    static toolName = name;\n  }\n  addTool(InstanceClass);\n}\n","import { DisplaySetService, classes } from '@ohif/core';\n\nconst ImageSet = classes.ImageSet;\n\nconst findInstance = (measurement, displaySetService: DisplaySetService) => {\n  const { displaySetInstanceUID, ReferencedSOPInstanceUID: sopUid } = measurement;\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n  if (!referencedDisplaySet.images) {\n    return;\n  }\n  return referencedDisplaySet.images.find(it => it.SOPInstanceUID === sopUid);\n};\n\n/** Finds references to display sets inside the measurements\n * contained within the provided display set.\n * @return an array of instances referenced.\n */\nconst findReferencedInstances = (displaySetService: DisplaySetService, displaySet) => {\n  const instances = [];\n  const instanceById = {};\n  for (const measurement of displaySet.measurements) {\n    const { imageId } = measurement;\n    if (!imageId) {\n      continue;\n    }\n    if (instanceById[imageId]) {\n      continue;\n    }\n\n    const instance = findInstance(measurement, displaySetService);\n    if (!instance) {\n      console.log('Measurement', measurement, 'had no instances found');\n      continue;\n    }\n\n    instanceById[imageId] = instance;\n    instances.push(instance);\n  }\n  return instances;\n};\n\n/**\n * Creates a new display set containing a single image instance for each\n * referenced image.\n *\n * @param displaySetService\n * @param displaySet - containing measurements referencing images.\n * @returns A new (registered/active) display set containing the referenced images\n */\nconst createReferencedImageDisplaySet = (displaySetService, displaySet) => {\n  const instances = findReferencedInstances(displaySetService, displaySet);\n  // This will be a  member function of the created image set\n  const updateInstances = function () {\n    this.images.splice(\n      0,\n      this.images.length,\n      ...findReferencedInstances(displaySetService, displaySet)\n    );\n    this.numImageFrames = this.images.length;\n  };\n\n  const imageSet = new ImageSet(instances);\n  const instance = instances[0];\n  imageSet.setAttributes({\n    displaySetInstanceUID: imageSet.uid, // create a local alias for the imageSet UID\n    SeriesDate: instance.SeriesDate,\n    SeriesTime: instance.SeriesTime,\n    SeriesInstanceUID: imageSet.uid,\n    StudyInstanceUID: instance.StudyInstanceUID,\n    SeriesNumber: instance.SeriesNumber || 0,\n    SOPClassUID: instance.SOPClassUID,\n    SeriesDescription: `${displaySet.SeriesDescription} KO ${displaySet.instance.SeriesNumber}`,\n    Modality: 'KO',\n    isMultiFrame: false,\n    numImageFrames: instances.length,\n    SOPClassHandlerId: `@ohif/extension-default.sopClassHandlerModule.stack`,\n    isReconstructable: false,\n    // This object is made of multiple instances from other series\n    isCompositeStack: true,\n    madeInClient: true,\n    excludeFromThumbnailBrowser: true,\n    updateInstances,\n  });\n\n  displaySetService.addDisplaySets(imageSet);\n\n  return imageSet;\n};\n\nexport default createReferencedImageDisplaySet;\n","import React from 'react';\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport getHangingProtocolModule, { srProtocol } from './getHangingProtocolModule';\nimport onModeEnter from './onModeEnter';\nimport getCommandsModule from './commandsModule';\nimport preRegistration from './init';\nimport { id } from './id.js';\nimport toolNames from './tools/toolNames';\nimport hydrateStructuredReport from './utils/hydrateStructuredReport';\nimport createReferencedImageDisplaySet from './utils/createReferencedImageDisplaySet';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSRViewport');\n});\n\nconst OHIFCornerstoneSRViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n *\n */\nconst dicomSRExtension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id,\n  onModeEnter,\n\n  preRegistration,\n\n  /**\n   *\n   *\n   * @param {object} [configuration={}]\n   * @param {object|array} [configuration.csToolsConfig] - Passed directly to `initCornerstoneTools`\n   */\n  getViewportModule({ servicesManager, extensionManager }) {\n    const ExtendedOHIFCornerstoneSRViewport = props => {\n      return (\n        <OHIFCornerstoneSRViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          {...props}\n        />\n      );\n    };\n\n    return [{ name: 'dicom-sr', component: ExtendedOHIFCornerstoneSRViewport }];\n  },\n  getCommandsModule,\n  getSopClassHandlerModule,\n  // Include dynamically computed values such as toolNames not known till instantiation\n  getUtilityModule({ servicesManager }) {\n    return [\n      {\n        name: 'tools',\n        exports: {\n          toolNames,\n        },\n      },\n    ];\n  },\n};\n\nexport default dicomSRExtension;\n\n// Put static exports here so they can be type checked\nexport { hydrateStructuredReport, createReferencedImageDisplaySet, srProtocol };\n","import { SOPClassHandlerId } from './id';\n\nexport default function onModeEnter({ servicesManager }) {\n  const { displaySetService } = servicesManager.services;\n  const displaySetCache = displaySetService.getDisplaySetCache();\n\n  const srDisplaySets = [...displaySetCache.values()].filter(\n    ds => ds.SOPClassHandlerId === SOPClassHandlerId\n  );\n\n  srDisplaySets.forEach(ds => {\n    // New mode route, allow SRs to be hydrated again\n    ds.isHydrated = false;\n  });\n}\n","import {\n  addTool,\n  AngleTool,\n  annotation,\n  ArrowAnnotateTool,\n  BidirectionalTool,\n  CobbAngleTool,\n  EllipticalROITool,\n  CircleROITool,\n  LengthTool,\n  PlanarFreehandROITool,\n} from '@cornerstonejs/tools';\nimport DICOMSRDisplayTool from './tools/DICOMSRDisplayTool';\nimport addToolInstance from './utils/addToolInstance';\nimport { Types } from '@ohif/core';\nimport toolNames from './tools/toolNames';\n\n/**\n * @param {object} configuration\n */\nexport default function init({ configuration = {} }: Types.Extensions.ExtensionParams): void {\n  addTool(DICOMSRDisplayTool);\n  addToolInstance(toolNames.SRLength, LengthTool, {});\n  addToolInstance(toolNames.SRBidirectional, BidirectionalTool);\n  addToolInstance(toolNames.SREllipticalROI, EllipticalROITool);\n  addToolInstance(toolNames.SRCircleROI, CircleROITool);\n  addToolInstance(toolNames.SRArrowAnnotate, ArrowAnnotateTool);\n  addToolInstance(toolNames.SRAngle, AngleTool);\n  // TODO - fix the SR display of Cobb Angle, as it joins the two lines\n  addToolInstance(toolNames.SRCobbAngle, CobbAngleTool);\n  // TODO - fix the rehydration of Freehand, as it throws an exception\n  // on a missing polyline. The fix is probably in CS3D\n  addToolInstance(toolNames.SRPlanarFreehandROI, PlanarFreehandROITool);\n\n  // Modify annotation tools to use dashed lines on SR\n  const dashedLine = {\n    lineDash: '4,4',\n  };\n  annotation.config.style.setToolGroupToolStyles('SRToolGroup', {\n    SRLength: dashedLine,\n    SRBidirectional: dashedLine,\n    SREllipticalROI: dashedLine,\n    SRCircleROI: dashedLine,\n    SRArrowAnnotate: dashedLine,\n    SRCobbAngle: dashedLine,\n    SRAngle: dashedLine,\n    SRPlanarFreehandROI: dashedLine,\n    global: {},\n  });\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\n\nconst state = {\n  TrackingUniqueIdentifier: null,\n  trackingIdentifiersByViewportId: {},\n};\n\n/**\n * This file is being used to store the per-viewport state of the SR tools,\n * Since, all the toolStates are added to the cornerstoneTools, when displaying the SRTools,\n * if there are two viewports rendering the same imageId, we don't want to show\n * the same SR annotation twice on irrelevant viewport, hence, we are storing the state\n * of the SR tools in state here, so that we can filter them later.\n */\n\nfunction setTrackingUniqueIdentifiersForElement(\n  element,\n  trackingUniqueIdentifiers,\n  activeIndex = 0\n) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  state.trackingIdentifiersByViewportId[viewport.id] = {\n    trackingUniqueIdentifiers,\n    activeIndex,\n  };\n}\n\nfunction setActiveTrackingUniqueIdentifierForElement(element, TrackingUniqueIdentifier) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const trackingIdentifiersForElement = state.trackingIdentifiersByViewportId[viewport.id];\n\n  if (trackingIdentifiersForElement) {\n    const activeIndex = trackingIdentifiersForElement.trackingUniqueIdentifiers.findIndex(\n      tuid => tuid === TrackingUniqueIdentifier\n    );\n\n    trackingIdentifiersForElement.activeIndex = activeIndex;\n  }\n}\n\nfunction getTrackingUniqueIdentifiersForElement(element) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (state.trackingIdentifiersByViewportId[viewport.id]) {\n    return state.trackingIdentifiersByViewportId[viewport.id];\n  }\n\n  return { trackingUniqueIdentifiers: [] };\n}\n\nexport {\n  setTrackingUniqueIdentifiersForElement,\n  setActiveTrackingUniqueIdentifierForElement,\n  getTrackingUniqueIdentifiersForElement,\n};\n","import { utilities, metaData } from '@cornerstonejs/core';\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\nimport getLabelFromDCMJSImportedToolData from './getLabelFromDCMJSImportedToolData';\nimport { adaptersSR } from '@cornerstonejs/adapters';\nimport { annotation as CsAnnotation } from '@cornerstonejs/tools';\nconst { locking } = CsAnnotation;\n\nconst { guid } = OHIF.utils;\nconst { MeasurementReport, CORNERSTONE_3D_TAG } = adaptersSR.Cornerstone3D;\n\nconst CORNERSTONE_3D_TOOLS_SOURCE_NAME = 'Cornerstone3DTools';\nconst CORNERSTONE_3D_TOOLS_SOURCE_VERSION = '0.1';\n\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\n\nconst convertCode = (codingValues, code) => {\n  if (!code || code.CodingSchemeDesignator === 'CORNERSTONEJS') {\n    return;\n  }\n  const ref = `${code.CodingSchemeDesignator}:${code.CodeValue}`;\n  const ret = { ...codingValues[ref], ref, ...code, text: code.CodeMeaning };\n  return ret;\n};\n\nconst convertSites = (codingValues, sites) => {\n  if (!sites || !sites.length) {\n    return;\n  }\n  const ret = [];\n  // Do as a loop to convert away from Proxy instances\n  for (let i = 0; i < sites.length; i++) {\n    // Deal with irregular conversion from dcmjs\n    const site = convertCode(codingValues, sites[i][0] || sites[i]);\n    if (site) {\n      ret.push(site);\n    }\n  }\n  return (ret.length && ret) || undefined;\n};\n\n/**\n * Hydrates a structured report, for default viewports.\n *\n */\nexport default function hydrateStructuredReport(\n  { servicesManager, extensionManager, appConfig },\n  displaySetInstanceUID\n) {\n  const annotationManager = CsAnnotation.state.getAnnotationManager();\n  const disableEditing = appConfig?.disableEditing;\n  const dataSource = extensionManager.getActiveDataSource()[0];\n  const { measurementService, displaySetService, customizationService } = servicesManager.services;\n\n  const codingValues = customizationService.getCustomization('codingValues', {});\n  const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  // TODO -> We should define a strict versioning somewhere.\n  const mappings = measurementService.getSourceMappings(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  if (!mappings || !mappings.length) {\n    throw new Error(\n      `Attempting to hydrate measurements service when no mappings present. This shouldn't be reached.`\n    );\n  }\n\n  const instance = DicomMetadataStore.getInstance(\n    displaySet.StudyInstanceUID,\n    displaySet.SeriesInstanceUID,\n    displaySet.SOPInstanceUID\n  );\n\n  const sopInstanceUIDToImageId = {};\n  const imageIdsForToolState = {};\n\n  displaySet.measurements.forEach(measurement => {\n    const { ReferencedSOPInstanceUID, imageId, frameNumber } = measurement;\n\n    if (!sopInstanceUIDToImageId[ReferencedSOPInstanceUID]) {\n      sopInstanceUIDToImageId[ReferencedSOPInstanceUID] = imageId;\n      imageIdsForToolState[ReferencedSOPInstanceUID] = [];\n    }\n    if (!imageIdsForToolState[ReferencedSOPInstanceUID][frameNumber]) {\n      imageIdsForToolState[ReferencedSOPInstanceUID][frameNumber] = imageId;\n    }\n  });\n\n  const datasetToUse = _mapLegacyDataSet(instance);\n\n  // Use dcmjs to generate toolState.\n  let storedMeasurementByAnnotationType = MeasurementReport.generateToolState(\n    datasetToUse,\n    // NOTE: we need to pass in the imageIds to dcmjs since the we use them\n    // for the imageToWorld transformation. The following assumes that the order\n    // that measurements were added to the display set are the same order as\n    // the measurementGroups in the instance.\n    sopInstanceUIDToImageId,\n    utilities.imageToWorldCoords,\n    metaData\n  );\n\n  const onBeforeSRHydration =\n    customizationService.getModeCustomization('onBeforeSRHydration')?.value;\n\n  if (typeof onBeforeSRHydration === 'function') {\n    storedMeasurementByAnnotationType = onBeforeSRHydration({\n      storedMeasurementByAnnotationType,\n      displaySet,\n    });\n  }\n\n  // Filter what is found by DICOM SR to measurements we support.\n  const mappingDefinitions = mappings.map(m => m.annotationType);\n  const hydratableMeasurementsInSR = {};\n\n  Object.keys(storedMeasurementByAnnotationType).forEach(key => {\n    if (mappingDefinitions.includes(key)) {\n      hydratableMeasurementsInSR[key] = storedMeasurementByAnnotationType[key];\n    }\n  });\n\n  // Set the series touched as tracked.\n  const imageIds = [];\n\n  // TODO: notification if no hydratable?\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\n    const toolDataForAnnotationType = hydratableMeasurementsInSR[annotationType];\n\n    toolDataForAnnotationType.forEach(toolData => {\n      // Add the measurement to toolState\n      // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\n      // files, and looking up the imageId from sopInstanceUIDToImageId results\n      // in the wrong value.\n      const frameNumber = (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\n      const imageId =\n        imageIdsForToolState[toolData.sopInstanceUid][frameNumber] ||\n        sopInstanceUIDToImageId[toolData.sopInstanceUid];\n\n      if (!imageIds.includes(imageId)) {\n        imageIds.push(imageId);\n      }\n    });\n  });\n\n  let targetStudyInstanceUID;\n  const SeriesInstanceUIDs = [];\n\n  for (let i = 0; i < imageIds.length; i++) {\n    const imageId = imageIds[i];\n    const { SeriesInstanceUID, StudyInstanceUID } = metaData.get('instance', imageId);\n\n    if (!SeriesInstanceUIDs.includes(SeriesInstanceUID)) {\n      SeriesInstanceUIDs.push(SeriesInstanceUID);\n    }\n\n    if (!targetStudyInstanceUID) {\n      targetStudyInstanceUID = StudyInstanceUID;\n    } else if (targetStudyInstanceUID !== StudyInstanceUID) {\n      console.warn('NO SUPPORT FOR SRs THAT HAVE MEASUREMENTS FROM MULTIPLE STUDIES.');\n    }\n  }\n\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\n    const toolDataForAnnotationType = hydratableMeasurementsInSR[annotationType];\n\n    toolDataForAnnotationType.forEach(toolData => {\n      // Add the measurement to toolState\n      // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\n      // files, and looking up the imageId from sopInstanceUIDToImageId results\n      // in the wrong value.\n      const frameNumber = (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\n      const imageId =\n        imageIdsForToolState[toolData.sopInstanceUid][frameNumber] ||\n        sopInstanceUIDToImageId[toolData.sopInstanceUid];\n\n      toolData.uid = guid();\n\n      const instance = metaData.get('instance', imageId);\n      const {\n        FrameOfReferenceUID,\n        // SOPInstanceUID,\n        // SeriesInstanceUID,\n        // StudyInstanceUID,\n      } = instance;\n\n      const annotation = {\n        annotationUID: toolData.annotation.annotationUID,\n        data: toolData.annotation.data,\n        metadata: {\n          toolName: annotationType,\n          referencedImageId: imageId,\n          FrameOfReferenceUID,\n        },\n      };\n\n      const source = measurementService.getSource(\n        CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n        CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n      );\n      annotation.data.label = getLabelFromDCMJSImportedToolData(toolData);\n      annotation.data.finding = convertCode(codingValues, toolData.finding?.[0]);\n      annotation.data.findingSites = convertSites(codingValues, toolData.findingSites);\n      annotation.data.site = annotation.data.findingSites?.[0];\n\n      const matchingMapping = mappings.find(m => m.annotationType === annotationType);\n\n      const newAnnotationUID = measurementService.addRawMeasurement(\n        source,\n        annotationType,\n        { annotation },\n        matchingMapping.toMeasurementSchema,\n        dataSource\n      );\n\n      if (disableEditing) {\n        const addedAnnotation = annotationManager.getAnnotation(newAnnotationUID);\n        locking.setAnnotationLocked(addedAnnotation, true);\n      }\n\n      if (!imageIds.includes(imageId)) {\n        imageIds.push(imageId);\n      }\n    });\n  });\n\n  displaySet.isHydrated = true;\n\n  return {\n    StudyInstanceUID: targetStudyInstanceUID,\n    SeriesInstanceUIDs,\n  };\n}\n\nfunction _mapLegacyDataSet(dataset) {\n  const REPORT = 'Imaging Measurements';\n  const GROUP = 'Measurement Group';\n  const TRACKING_IDENTIFIER = 'Tracking Identifier';\n\n  // Identify the Imaging Measurements\n  const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\n    codeMeaningEquals(REPORT)\n  );\n\n  // Retrieve the Measurements themselves\n  const measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(\n    codeMeaningEquals(GROUP)\n  );\n\n  // For each of the supported measurement types, compute the measurement data\n  const measurementData = {};\n\n  const cornerstoneToolClasses = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\n  const registeredToolClasses = [];\n\n  Object.keys(cornerstoneToolClasses).forEach(key => {\n    registeredToolClasses.push(cornerstoneToolClasses[key]);\n    measurementData[key] = [];\n  });\n\n  measurementGroups.forEach((measurementGroup, index) => {\n    const measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n\n    const TrackingIdentifierGroup = measurementGroupContentSequence.find(\n      contentItem => contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER\n    );\n\n    const TrackingIdentifier = TrackingIdentifierGroup.TextValue;\n\n    let [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\n    if (supportedLegacyCornerstoneTags.includes(cornerstoneTag)) {\n      cornerstoneTag = CORNERSTONE_3D_TAG;\n    }\n\n    const mappedTrackingIdentifier = `${cornerstoneTag}:${toolName}`;\n\n    TrackingIdentifierGroup.TextValue = mappedTrackingIdentifier;\n  });\n\n  return dataset;\n}\n\nconst toArray = function (x) {\n  return Array.isArray(x) ? x : [x];\n};\n\nconst codeMeaningEquals = codeMeaningName => {\n  return contentItem => {\n    return contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName;\n  };\n};\n","/**\n * Extracts the label from the toolData imported from dcmjs. We need to do this\n * as dcmjs does not depeend on OHIF/the measurementService, it just produces data for cornestoneTools.\n * This optional data is available for the consumer to process if they wish to.\n * @param {object} toolData The tooldata relating to the\n *\n * @returns {string} The extracted label.\n */\nexport default function getLabelFromDCMJSImportedToolData(toolData) {\n  const { findingSites = [], finding } = toolData;\n\n  let freeTextLabel = findingSites.find(fs => fs.CodeValue === 'CORNERSTONEFREETEXT');\n\n  if (freeTextLabel) {\n    return freeTextLabel.CodeMeaning;\n  }\n\n  if (finding && finding.CodeValue === 'CORNERSTONEFREETEXT') {\n    return finding.CodeMeaning;\n  }\n}\n"],"names":["id","packageJson","SOPClassHandlerName","SOPClassHandlerId","POINT","MULTIPOINT","POLYLINE","CIRCLE","ELLIPSE","DICOMSRDisplayTool","AnnotationTool","constructor","toolProps","defaultToolProps","configuration","super","isPointNearTool","getHandleNearImagePoint","renderAnnotation","enabledElement","svgDrawingHelper","viewport","element","annotations","annotation","this","getToolName","length","filterInteractableAnnotationsForElement","trackingUniqueIdentifiersForElement","getTrackingUniqueIdentifiersForElement","activeIndex","trackingUniqueIdentifiers","activeTrackingUniqueIdentifier","filteredAnnotations","filter","includes","data","cachedStats","TrackingUniqueIdentifier","_actors","size","styleSpecifier","toolGroupId","toolName","viewportId","i","annotationUID","renderableData","referencedImageId","metadata","lineWidth","getStyle","lineDash","options","color","Object","keys","forEach","GraphicType","renderableDataForGraphicType","renderMethod","canvasCoordinatesAdapter","SCOORD_TYPES","renderPoint","renderMultipoint","renderPolyLine","renderEllipse","utilities","Error","canvasCoordinates","renderTextBox","_getTextBoxLinesFromLabels","labels","labelLength","Math","min","lines","labelEntry","push","_labelToShorthand","label","value","drawingOptions","width","allCanvasCoordinates","map","index","p","worldToCanvas","lineUID","drawing","concat","point","imagePixelModule","metaData","xOffset","yOffset","columns","rows","imagePoint","csUtils","arrowEnd","arrowUID","ellipsePointsWorld","rotation","getRotation","canvasCorners","adaptedCanvasCoordinates","textLines","canvasTextBoxCoords","handles","textBox","worldPosition","canvasToWorld","textBoxPosition","textBoxOptions","getLinkedTextBoxStyle","boundingBox","x","left","y","top","height","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","SHORT_HAND_MAP","AREA","Length","CORNERSTONEFREETEXT","shortHand","undefined","DICOMSRDisplay","SRLength","SRBidirectional","SREllipticalROI","SRCircleROI","SRArrowAnnotate","SRAngle","SRCobbAngle","SRRectangleROI","SRPlanarFreehandROI","EPSILON","addMeasurement","measurement","imageId","displaySetInstanceUID","toolNames","measurementData","coords","coord","GraphicData","TrackingIdentifier","cornerstoneTag","split","worldPos","pointsWorld","center","onPerimeter","radius","vec3","imagePlaneModule","columnCosines","rowCosines","firstAxisStart","firstAxisEnd","secondAxisStart","secondAxisEnd","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","abs","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","console","warn","_getRenderableData","annotationManager","frameNumber","ReferencedSOPSequence","ReferencedFrameNumber","SRAnnotation","FrameOfReferenceUID","frameOfReferenceUID","addAnnotation","loaded","ReferencedSOPInstanceUID","cornerstoneAdapters","adaptersSR","Cornerstone3D","MeasurementReport","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","supportedLegacyCornerstoneTags","CORNERSTONE_3D_TAG","CodeScheme","Cornerstone3DCodeScheme","ImageSet","MetadataProvider","metadataProvider","classes","sopClassUids","CORNERSTONE_3D_TOOLS_SOURCE_NAME","CORNERSTONE_3D_TOOLS_SOURCE_VERSION","validateSameStudyUID","uid","instances","it","StudyInstanceUID","SOPInstanceUID","CodeNameCodeSequenceValues","ImagingMeasurementReport","ImageLibrary","ImagingMeasurements","MeasurementGroup","ImageLibraryGroup","Finding","FindingSite","CornerstoneFreeText","codeValues","CodingSchemeDesignators","SRT","CornerstoneCodeSchemes","CodingSchemeDesignator","RELATIONSHIP_TYPE","INFERRED_FROM","CONTAINS","CORNERSTONE_FREETEXT_CODE_VALUE","addInstances","displaySetService","utils","sortStudyInstances","instance","isLoaded","_getDisplaySetsFromSeries","servicesManager","extensionManager","SeriesInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","ConceptNameCodeSequence","SOPClassUID","CodeValue","services","uiNotificationService","show","title","message","type","duration","displaySet","Modality","guid","referencedImages","measurements","isDerivedDisplaySet","load","measurementService","dataSources","getDataSources","dataSource","ContentSequence","ImagingMeasurementReportContentSequence","_getSequenceAsArray","find","item","ref","ReferencedSOPClassUID","_getReferencedImagesList","mergedContentSequencesByTrackingUniqueIdentifiers","MeasurementGroups","TrackingUniqueIdentifierItem","trackingUniqueIdentifier","UID","_getMergedContentSequencesByTrackingUniqueIdentifiers","mergedContentSequence","some","group","ValueType","graphicItem","UIDREFContentItem","TrackingIdentifierContentItem","NUMContentItems","_getCoordsFromSCOORDOrSCOORD3D","TextValue","MeasuredValueSequence","_getLabelFromMeasuredValueSequence","_processTID1410Measurement","finding","findingSites","ConceptCodeSequence","CodeMeaning","cornerstoneFreeTextFindingSite","_processNonGeometricallyDefinedMeasurement","_processMeasurement","_getMeasurements","mappings","getSourceMappings","isHydrated","isRehydratable","mappingDefinitions","m","annotationType","adapterKeys","adapterKey","isValidCornerstoneTrackingIdentifier","adapters","key","adapter","mappedTrackingIdentifier","log","activeDisplaySets","activeDisplaySet","_checkIfCanAddMeasurementsToDisplaySet","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","newDisplaySet","_load","srDisplaySet","customizationService","unloadedMeasurements","unsupported","SOPInstanceUIDs","imageIdsForDisplaySet","getImageIdsForDisplaySet","getUIDsFromImageID","j","onBeforeSRAddMeasurement","getModeCustomization","_measurementReferencesSOPInstanceUID","splice","Number","RelationshipType","ReferencedFrameOfReferenceSequence","NumericValue","MeasurementUnitsCodeSequence","toFixed","sequence","Array","isArray","name","getDisplaySetsFromSeries","srProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","srDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","viewports","OHIF","additionalFindingTypes","filteredToolState","addToFilteredToolState","toolType","imageIdSpecificToolState","measurementDataI","md","toolData","assign","uids","slice","framesOfReference","getFramesOfReference","frameOfReference","frameOfReferenceAnnotations","getAnnotations","toolTypes","k","uidIndex","findIndex","props","actions","downloadReport","srDataset","generateReport","reportBlob","dcmjs","datasetToBlob","objectUrl","URL","createObjectURL","window","location","storeMeasurements","async","info","store","dicom","error","Promise","reject","naturalizedReport","_generateReport","getFilteredCornerstoneToolState","report","dataset","SpecificCharacterSet","onBeforeDicomStore","dicomDict","deleteStudyMetadataPromise","DicomMetadataStore","definitions","commandFn","storeContexts","defaultContext","addToolInstance","toolClass","InstanceClass","addTool","findInstance","sopUid","referencedDisplaySet","getDisplaySetByUID","images","findReferencedInstances","instanceById","createReferencedImageDisplaySet","imageSet","setAttributes","SeriesTime","isMultiFrame","numImageFrames","isReconstructable","isCompositeStack","madeInClient","excludeFromThumbnailBrowser","updateInstances","addDisplaySets","Component","React","OHIFCornerstoneSRViewport","fallback","onModeEnter","getDisplaySetCache","values","ds","preRegistration","LengthTool","BidirectionalTool","EllipticalROITool","CircleROITool","ArrowAnnotateTool","AngleTool","CobbAngleTool","PlanarFreehandROITool","dashedLine","setToolGroupToolStyles","global","getViewportModule","component","_extends","getCommandsModule","getSopClassHandlerModule","getUtilityModule","exports","state","trackingIdentifiersByViewportId","setTrackingUniqueIdentifiersForElement","getEnabledElement","locking","CsAnnotation","convertCode","codingValues","code","text","convertSites","sites","ret","site","hydrateStructuredReport","appConfig","disableEditing","getActiveDataSource","getCustomization","getInstance","sopInstanceUIDToImageId","imageIdsForToolState","datasetToUse","REPORT","GROUP","TRACKING_IDENTIFIER","imagingMeasurementContent","toArray","codeMeaningEquals","measurementGroups","cornerstoneToolClasses","registeredToolClasses","measurementGroup","TrackingIdentifierGroup","contentItem","_mapLegacyDataSet","storedMeasurementByAnnotationType","generateToolState","onBeforeSRHydration","hydratableMeasurementsInSR","imageIds","targetStudyInstanceUID","sopInstanceUid","SeriesInstanceUIDs","source","getSource","freeTextLabel","fs","getLabelFromDCMJSImportedToolData","matchingMapping","newAnnotationUID","addRawMeasurement","toMeasurementSchema","addedAnnotation","getAnnotation","setAnnotationLocked","codeMeaningName"],"sourceRoot":""}